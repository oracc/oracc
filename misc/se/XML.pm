package ORACC::SE::XML;
use warnings; use strict; 
use open ':utf8'; 
use utf8;
use Encode;
use ORACC::SE::DBM;

binmode STDOUT, ':utf8'; binmode STDERR, ':utf8';

my $ORACC_SE_COMMENT = "<!-- Created by ORACC::SE: DO NOT EDIT THIS FILE! -->";

# DeSerialize from XML to an in-memory hash
sub
fromXML {
    my $name = shift;
    my %db = ();
    open(XML,"02xml/$name-db.xml");
    $_ = <XML>; # discard the <?xml ...?> line
    $_ = <XML>; # scan the comment line
    die "XML.pm: not a ORACC::SE::XML file\n" 
	unless /^$ORACC_SE_COMMENT$/;
    while (<XML>) {
	next unless s/^\s*<(grep|k|r)(?:\s+(.*?))?>//;
	my ($tag,$attr) = ($1,$2);
	if ($tag eq 'grep') {
	    $attr =~ s/^.*?\"//; $attr =~ s/\"\s*$//;
	    my @g = ();
	    while (<XML>) {
		last if m,</grep>,;
		push @g, $_;
	    }
	    $db{$attr} = join('',@g);
	} elsif ($tag eq 'r') {
	    my @r = ($_);
	    while (!m,</r>,) {
		$_ = <XML>;
		push @r, $_;
	    }
	    chomp($r[$#r]);
	    $r[0] =~ s/^<key><\!\[CDATA\[//;
	    $r[$#r] =~ s,</r>$,,;
	    $r[$#r] =~ s,<ids>(.*?)</ids>,,;
	    my $ids = $1;
	    $r[$#r] =~ s,\]\]></key>,,;
	    my $key = join('',@r);
	    $db{$key,'r'} = $ids;
	    foreach my $id (split(/\s+/, $ids)) {
		$db{$id,'i2r'} = $key;
	    }
	} elsif ($tag eq 'k') {
	    my @k = ($_);
	    while (!m,</k>,) {
		$_ = <XML>;
		push @k, $_;
	    }
	    my $k = join('', @k);
	    $k =~ s/<\/k>\s*$//;
	    my $n;
	    ($n) = ($attr =~ /n=\"(.*?)\"/);
	    if ($attr =~ /f=\"(.*?)\"/) {
		$db{$n,'f'} = $1;
	    }
	    if ($n eq '#fields') {
		$db{$n} = [ split(/\s+/,$k) ];
	    } else {
		if ($n =~ /^(.*?);(.*?)$/) {
		    $db{$1,$2} = $k;
		} else {
		    $db{$n} = $k;
		}
	    }
	} else {
	    die "XML.pm: unhandled tag '$tag'\n";
	}
    }
    close(XML);
    \%db;
}

# Serialize an in-memory or disk-based DBM to XML
sub
toXML {
    my $ix = shift;
    my $name = $$ix{'#name'};
    use Data::Dumper; open(D,">01tmp/$name.dbg"); binmode(D,':raw'); print D Dumper($ix); close(D);
    open(XML,">:raw", "02xml/$name-db.xml"); select XML;
    print '<?xml version="1.0" encoding="utf-8"?>',"\n";
    print $ORACC_SE_COMMENT, "\n";
    print "<hash>\n";
#    print_grep($ix,'#record_grep');
#    print_grep($ix,'#item_grep');
    my $fldtype = ref($$ix{'#fields'});
    if ($fldtype eq 'ARRAY') {
	foreach my $f (@{$$ix{'#fields'}}) {
#	    print_grep($ix,"#${f}_grep");
	    print_grep($ix,"#${f}:item_grep");
	}
    } else {
	foreach my $f (split(/\s+/,$$ix{'#fields'})) {
#	    print_grep($ix,"#${f}_grep");
	    print_grep($ix,"#${f}:item_grep");
	}
    }

    $ix = ORACC::SE::DBM::flatten($ix);

    if ($$ix{'#use_grep'}) {
	foreach my $k (grep /r$/, sort keys %$ix) {
	    my $cdata = $k;
	    $cdata =~ s/r$//;
	    print "<r><key><![CDATA[$cdata]]></key>";
	    my $pk = xmlify($$ix{$k});
	    print "<ids>$pk</ids></r>\n";
	}
    }

    if ($$ix{'#all_keys'}) {
	foreach my $k (keys %$ix) {
	    next if $k =~ /^\#.*?(item|record)_grep$/;
	    if (defined $$ix{$k}) {
		my $f = '';
		if (defined $$ix{$k,'f'}) {
		    my $f = xmlify($$ix{$k,'f'});
		    $f = " f=\"$f\"";
		}
		my $pk = xmlify($k);
		$pk =~ tr//;/;
		Encode::_utf8_off($pk);
		print "<k n=\"$pk\"$f>";
		my $pv = xmlify($$ix{$k});
		Encode::_utf8_off($pv);
		print $pv;
		print "</k>\n";
	    }
	}
    } else {
	foreach my $k (grep !//, sort keys %$ix) {
	    next if $k =~ /^\#.*?(item|record)_grep$/;
	    if (defined $$ix{$k}) {
		my $f = '';
		if (defined $$ix{$k,'f'}) {
		    $f = " f=\"$$ix{$k,'f'}\"";
		}
		my $pk = xmlify($k);
		Encode::_utf8_off($pk);
		print "<k n=\"$pk\"$f>";
		Encode::_utf8_off($$ix{$k});
		print $$ix{$k};
		print "</k>\n";
	    }
	}
    }
    print "</hash>";
    close(XML);
}

sub
print_grep {
    my ($ix,$type) = @_;
    return unless defined $$ix{$type};
    my $data_type = ref($$ix{$type});
    print "<grep type=\"$type\">\n";
    if ($data_type eq 'HASH') {
	print join("\n", map { Encode::_utf8_off($_); $_ } sort keys %{$$ix{$type}}), "\n";
    } elsif ($data_type eq 'ARRAY') {
	print join("\n", @{$$ix{$type}}), "\n";
    } elsif (!$data_type || $data_type eq 'SCALAR') {
	print $$ix{$type};
#	print "\n" unless $$ix{$type} =~ /\n$/;
    } else {
	die "ref ix{$type} == $data_type\n";
    }
    print "</grep>\n";
}

sub
xmlify {
    my $tmp = shift;
    $tmp =~ s/\&/\&amp;/g;
    $tmp =~ s/\"/\&quot;/g;
    $tmp;
}
1;
