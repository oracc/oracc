#!/usr/bin/perl
use warnings; use strict; use open 'utf8'; use utf8;
use lib "@@ORACC@@/lib";
use Getopt::Long;
use Pod::Usage;
use ORACC::Expand2;
use ORACC::Log::Util;
use ORACC::XML;
use ORACC::NS;
use ORACC::FXR::Util;
use ORACC::XMD::CSV;
use ORACC::XMD::TSV;
use ORACC::XMD::Util;
use ORACC::XMD::Fields;
use ORACC::XVL::AVL;

sub xsystem;

use Data::Dumper;
my $catd_debug = 0;
open(CATDUMP,'>cat.dump')
    if $catd_debug;

binmode STDIN, ':utf8';
binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';

my %merge_periods_all = (
    'Uruk V'=>'Archaic',
    'Uruk IV'=>'Archaic',
    'Uruk III'=>'Archaic',
    'Archaic'=>'Archaic',
    'Early Dynastic I-II'=>'Early Dynastic I-II',
    'ED I-II'=>'Early Dynastic I-II',
    'ED IIIa'=>'Early Dynastic IIIa',
    'Early Dynastic IIIa'=>'Early Dynastic IIIa',
    'Early Dynastic'=>'Early Dynastic IIIb',
    'ED IIIb'=>'Early Dynastic IIIb',
    'Early Dynastic IIIb'=>'Early Dynastic IIIb',
    'Ebla'=>'Ebla',
    'Old Akkadian'=>'Old Akkadian',
    'Lagash II'=>'Lagash II',
    'LagaÅ¡ II'=>'Lagash II',
    'Ur III'=>'Ur III',
    'Harappan'=>'Ur III',
    'Early Old Babylonian'=>'Old Babylonian',
    'Old Assyrian'=>'Old Babylonian',
    'Old Babylonian'=>'Old Babylonian',
    'Middle Assyrian'=>'Middle Assyrian',
    'Middle Babylonian'=>'Middle Babylonian',
    'Middle Hittite'=>'Middle Babylonian',
    'Kassite'=>'Kassite',
    'First Millennium'=>'Neo-Assyrian',
    'Standard Babylonian'=>'Neo-Assyrian',
    'Early Neo-Babylonian'=>'Neo-Babylonian',
    'Neo-Babylonian'=>'Neo-Babylonian',
    'Neo-Assyrian'=>'Neo-Assyrian',
    'Persian'=>'Persian',
    'Late Babylonian'=>'Persian',
    'Achaemenid'=>'Persian',
    'Hellenistic'=>'Hellenistic',
    'Seleucid'=>'Hellenistic',
    'Parthian'=>'Parthian',
    'Sassanian'=>'Sassanian',
    'Uncertain'=>'Uncertain',
    'uncertain'=>'Uncertain',
    'Unknown'=>'Uncertain',
    'unknown'=>'Uncertain'
    );

my %merge_periods = ();
foreach my $mp (keys %merge_periods_all) {
    if ($mp ne $merge_periods_all{$mp}) {
	$merge_periods{$mp} = $merge_periods_all{$mp};
    }
}

# open(MP, ">mergeperiods.dump"); print MP Dumper \%merge_periods; close(MP);

umask 022;

my %xmd_outputs = ();
my $curr_xmd = '';

my $oracc_mode = 0;
my $project_mode = 0;
my %seen = ();
my %id_projects = ();
#my $l2_value = `xpd.plx l2`;
#my $l2 = ($l2_value eq 'yes' ? 1 : 0);
my $l2 = 1;
my %vid = ();
my @vid = ();

my $config = '';
my %catd = ();
my %catd_fields = ();
#my %extra_catd = ();
my $geojson_first = 1;
my $json_first = 1;

my $no_xmd = 0;
my $onebigfile = 1;
my $output_all = 1;
my %output_records = ();
my $pacifier = 0;
my @pleiades_data = ();
my %pleiades = ();
my $project_designation_codes = 0;
my %proj_des_sort = ();
my $proxying = 0;
my %skip_list = ();
my $skip_xmd = 0;
my $split = 1;
my $update = 0;
my $validate = 1;
my $verbose = 0;

my %json_ignore = ();
my @json_ignore = qw/ark_number date_entered date_remarks date_updated db_source public public_atf public_images id/;
@json_ignore{@json_ignore} = ();

my %langmasks = (
    'misc'           =>0x01000000,
    'sumerian'       =>0x02000000,
    'akkadian'       =>0x08000000,
    'proto-cuneiform'=>0x10000000,
    'proto-elamite'  =>0x20000000,
    );
my $lmattr = '';
my %unknown_langs = ();

my %ns_types = (
    'http://www.filemaker.com/fmpxmlresult'=>'fxr',
    'http://oracc.org/ns/xmd/1.0'=>'xmd',
    );

my $xmlsplit = "@@ORACC@@/bin/xmlsplit";
my $kd_rnc = "@@ORACC@@/lib/schemas/xmd-keydata.rnc";
my $kd_uri = 'http://oracc.org/ns/keydata/1.0';
my $log_xsl = "@@ORACC@@/lib/scripts/log-HTML.xsl";

my %xproject = ();
my %xproject_uris = (
    'CDLI'=>'http://cdli.ucla.edu',
    'DCCLT'=>'http://cuneiform.ucla.edu/dcclt',
    'ETCSL'=>'http://www-etcsl.orient.ox.ac.uk',
    );

my $imgdb = "@@ORACC@@/xml/cdli/imgdb.xml";
my $imgdoc = load_xml($imgdb);
#die "xmdmanager.plx: can't open image database $imgdb\n" unless $imgdoc;
warn "xmdmanager.plx: can't open image database $imgdb\n" unless $imgdoc;

my $pubimg_lst = "@@ORACC@@/pub/cdli/public_image.lst";
my %pubimg = ();

my %nifs = ();
my @currvt = ();
my %valtab = ();

# Variables to be set in config file:
my $basename = '';
my $catdir = '';
my @cat_masters = ();
my $cat_merge_periods = `oraccopt . cat-merge-periods`;
my $dynacat = '';
my $force = 0; # not used; just for oraccproject
my $results = '';
my $keydata = '';
my $logfile = '';
my $loghtml = '';
my $project = '';
my $public = '';
my $xml = '';
my @catalogs = ();
my %tix_warned = ();

my %orig = ();

GetOptions(
    'config:s'=>\$config,
    'dynacat:s'=>\$dynacat,
    'force'   =>\$force,
    'noxmd'   =>\$no_xmd,
    'project:s' =>\$project,
    'skipxmd' =>\$skip_xmd,
    'split'   =>\$split,
    'update'  =>\$update,
    'validate'=>\$validate,
    'verbose' =>\$verbose,
    ) || pod2usage(1);

$catdir  = '00cat'; # ${$r{'catdir'}}[0];
$results = '01bld'; # ${$r{'results'}}[0];
$public = '02pub'; # ${$r{'results'}}[0];
$xml = '02xml'; # ${$r{'results'}}[0];
$logfile = '01tmp/last-catalog-build.xml'; # ${$r{'logfile'}}[0];
$loghtml = '02www/last-catalog-build.html'; # ${$r{'loghtml'}}[0];

$project = `oraccopt`
    unless $project;
die "xmdmanager2.plx: must run from project directory (no '00lib/config.xml')\n"
    unless $project;
my $projectDir = "$project/";

unless ($project eq 'cdli') {
    if (open(P,$pubimg_lst)) {
	while (<P>) {
	    chomp;
	    ++$pubimg{$_};
	}
	close(P);
    } else {
	warn "xmdmanager2.plx: can't open $pubimg_lst";
    }
}

if (-r '00lib/designation-sort-order.lst') {
    load_designation_sort_order();
} elsif (-r '00lib/designation-sort-codes.lst') {
    load_designation_sort_codes();
}

my %translist = ();
if (-r '01bld/translist.txt') {
    load_translist();
}

extra_init_hash();
#open(D,">01tmp/extra_init_hash.dump");
#print D Dumper \%catd;
#close(D);

my $cat_pleiades = `oraccopt . catalog-pleiades`;

if ($cat_pleiades) {
    use ORACC::XMD::Pleiades;
    pleiades_init($project);
}

my $pub_cat = `oraccopt . catalog-publish`;
foreach my $c (split(/,/,$pub_cat)) {
    my $cat_c = "00cat/$c";
    unless (-r $cat_c) {
	$cat_c = "00lib/$c";
	warn("xmdmanager: `$c' no such catalogue to publish (tried 00cat and 00lib)\n") and next
	    unless -r $cat_c;
    }
    my $type = type_from_ns($cat_c);
    my @res = ("02pub/$c");
    if ($type eq 'fxr') {
	$res[0] =~ s#\.[^./]+$#.xml#;
	xsystem 'unfxr.plx', '-fxr', $cat_c, '-res', $res[0];
    } else {
	xsystem 'cp', '-p', $cat_c, '02pub';
    }
    if (-r '00lib/keydata.xml') {
	xsystem 'cp', '-p', '00lib/keydata.xml', '02pub';
	push @res, '02pub/keydata.xml';
    }
    xsystem 'chmod', 'o+r', @res;
}
my $projtype = `oraccopt . type`;
my $cat_policy = `oraccopt . catalog-build-policy`;

unless ($cat_policy) {
    if ($projtype eq 'superglo') {
	$cat_policy = 'virtual';
    } else {
	$cat_policy = 'mixed';
    }
}

warn "catalog-build-policy=$cat_policy\n" if $verbose;
exit(0) if $cat_policy eq 'none';

# open the log file; we create an XML report on the
# run which is turned into a web page on the XMD doco
open(LOG,">utf8", $logfile) || die "xmdmanager: $logfile: failed to open logfile\n";
print LOG xmldecl();
print LOG 
    '<log xmlns="http://oracc.org/ns/log/1.0" date="',
    `date`,
    "\">\n";
my $locator = undef;

if ($cat_policy eq 'auto') {
    make_dynacat();
} elsif ($cat_policy eq 'virtual') {
    make_vcat();
    $split = 0;
} elsif ($cat_policy eq 'derived') {
    setup_derived_cat();
} elsif ($cat_policy eq 'mixed' || $cat_policy eq 'custom' || $cat_policy eq 'local') {
    @catalogs = map { { 'file'=>$_ } }  <00cat/*.xml>, <00cat/*.csv>, <00cat/*.tsv>;
} else {
    die "xmdmanager2.plx: unhandled catalogue type $cat_policy\n";
}

if (-r '01bld/lists/proxy-cat.lst') {
    xsystem 'xmd-proxy.plx';
    push @catalogs, map { { 'file'=>$_ } } <01bld/cat/proxy-*.xml>;
#    open(P,'01bld/lists/proxy-cat.lst');
    open(P,'01bld/lists/proxy-atf.lst');
    while (<P>) {
	next if /^\s*$/;
	chomp;
	my($xtf,$id,$xmd) = ();
	
	if (/:.*?\@/) {
	    ($xtf,$id,$xmd) = (/^(.*?):(.*?)\@(.*?)$/);
	} elsif (/:/) {
	    ($xtf,$id) = (/^(.*?):(.*?)$/);
	    $xmd = $xtf;
	} elsif (/\@/) {
	    ($id,$xmd) = (/^(.*?)\@(.*?)$/);
	    $xtf = $project;
	} else {
	    warn "xmdmanager2.plx: ignoring bare ID $_ in proxy-atf.lst\n";
	    next;
	}
	
	$id_projects{$id,'xtf'} = $xtf;
	$id_projects{$id,'xmd'} = $xmd;
    }
    close(P);
}

# check that all the approved texts are in a catalogue somewhere, and make a dynacat of any we need
if ($cat_policy eq 'mixed') {
    xsystem '@@ORACC@@/bin/atflists.plx', '-o01bld/lists/cat-needed.lst', '01bld/lists/approved.lst', '-', '01bld/lists/cat-ids.lst';
    my @todo = `cat 01bld/lists/cat-needed.lst`; chomp @todo;
    if ($#todo >= 0) {
	make_dynacat(@todo);
    }
}

$keydata = find_keydata() unless $keydata;

if ($#catalogs >= 0) {
    foreach my $c (@catalogs) {
	$$c{'type'} = type_from_ns($$c{'file'});
	warn "xmdmanager: reading catalogue data from $$c{'file'}\n";
	$$c{'locator'} = ORACC::Log::Util::create_locator(file=>$$c{'file'});
	if ($$c{'type'} eq 'fxr') {
	    $$c{'icat'} = [ ORACC::FXR::Util::internalize($$c{'file'}) ];
	} elsif ($$c{'type'} eq 'xmd' || $$c{'type'} eq 'xml') {
	    $$c{'icat'} = [ ORACC::XMD::Util::internalize($$c{'file'}) ];
	} elsif ($$c{'type'} eq 'csv') {
	    $$c{'icat'} = [ ORACC::XMD::CSV::internalize($$c{'file'}) ];
	} elsif ($$c{'type'} eq 'tsv') {
	    $$c{'icat'} = [ ORACC::XMD::TSV::internalize($$c{'file'}) ];
	} else {
	    die "xmdmanager.plx: unknown catalog type $$c{'type'}\n";
	}
	import_catd($$c{'icat'});
    }
}

# internalize the keydata for rapid access and to enable
# the value arrays to be extended dynamically if we find new 
# ones
my %badremaps = ();
my %badvalues = ();
my %keydata = ();
my %nonindexed_fields = ();
my %valdefs = ();
my %value_counts = ();
my %remaps = ();
my %sortable_hrs = ();
my %sortable_types = ();
my %sortvals = ();
my %split_sortkeys = ();
my %stringpool = ();
my %type_counts = ();
my %type_indexes = ();
my %typeinfo = ();
my %typemap = ();
my %xru = ();

my $did_valtab = 0;

my $stringpool_index = 0;
$stringpool{'unknown'} = $stringpool_index++;

# Validate and load keydata
#rnv($kd_rnc,$keydata,$verbose);
my $kd = load_xml($keydata);
my $kdoc = $kd->getDocumentElement();

# load names of keys which don't get indexed
foreach my $n (tags($kdoc,$kd_uri,'not-indexed')) {
    foreach my $f (tags($n,$kd_uri,'field')) {
	++$nonindexed_fields{$f->getAttribute('n')};
	++$nifs{$f->getAttribute('n')};
    }
}

# load types table which maps field names to field types
my %fields_of_types = ();
foreach my $s ($kdoc->getElementsByTagNameNS($kd_uri,
					     'keytype')) {
#    my $field = $s->getAttribute('n');
#    my $type = $s->getAttribute('type');
    $typemap{$s->getAttribute('n')} = $s->getAttribute('type');
    push @{$fields_of_types{$s->getAttribute('type')}}, $s->getAttribute('n');
}

my @nvt = ();
# load the sortable types list
my $typindex = 0;
my $nvt_fields = 0;
foreach my $s (tags($kdoc,$kd_uri,'sortable')) {
    foreach my $t (tags($s,$kd_uri,'type')) {
	my $n = $t->getAttribute('n');
	++$sortable_types{$n};
	$sortable_hrs{$n} = $t->getAttribute('hr');
	push @nvt, "\#field @{$fields_of_types{$n}} = $sortable_hrs{$n}\n";
	$nvt_fields += $#{$fields_of_types{$n}}+1;
	foreach my $f (@{$fields_of_types{$n}}) {
	    warn("type_index{$f}= $typindex\n") if $verbose;
	    $type_indexes{$f} = $typindex;
	}
	++$typindex;
    }
    foreach my $t (tags($s,$kd_uri,'field')) {
	my $n = $t->getAttribute('n');
	$sortable_hrs{$n} = $t->getAttribute('hr');
	++$sortable_types{$n};
	push @nvt, "\#field $n = $sortable_hrs{$n}\n";
	$type_indexes{$n} = $typindex++;
	++$nvt_fields;
	$typemap{$n} = $n; # fake the typemap info for fields
	push @{$fields_of_types{$n}}, $n; # and fake fields_of_types, too
    }
}

print STDERR @nvt if $verbose;

# load the key type info
foreach my $k ($kdoc->getElementsByTagNameNS($kd_uri,
					     'keys')) {
    my $type = $k->getAttribute('type') || $k->getAttribute('field');
    $typeinfo{$type} = { 
	node=>$k,
	class=>$k->getAttribute('class'),
	method=>$k->getAttribute('method'),
	reorder=>$k->getAttribute('reorder'),
	remap=>$k->getAttribute('remap'),
	queryable=>$k->getAttribute('queryable') };
    if ($k->hasAttribute('value-set')) {
	my $class = $k->getAttribute('value-set');
	ORACC::XVL::AVL::load_class($class);
	@{$keydata{$type}} = ORACC::XVL::AVL::list($class);
	@{$valdefs{$type}}{ @{$keydata{$type}} } = (1..$#{$keydata{$type}});
	my $x = ORACC::XVL::AVL::values($class);
	foreach my $n (keys %$x) {
	    push @{$keydata{$type}}, $n;
	    ++${$valdefs{$type}}{$n};
	}
    } else {
	foreach my $v ($k->childNodes()) {
	    my $n = $v->getAttribute('n');
	    push @{$keydata{$type}}, $n;
	    ++${$valdefs{$type}}{$n};
	}
    }
}

open_tab_files()
    unless $cat_policy eq 'none';

foreach my $c (@catalogs) {
    $locator = $$c{'locator'};
    remap($$c{'icat'});
    if ($project_mode) {
	$$c{'icat'} = imports($$c{'icat'});
	$$c{'icat'} = inherits($$c{'icat'});
#	use Data::Dumper; print Dumper($$c{'icat'});
	xproject_bis($$c{'icat'},$$c{'file'});
    } else {
	xproject($$c{'icat'},$$c{'file'});
    }
    check_vals($$c{'icat'});
}

unless ($cat_policy eq 'none') {
    close(QNMTAB);
    close(PNMTAB);
    close(PERTAB);
    close(LOCTAB);
    dump_bad();
}

exit 0 if $no_xmd;

# generate the sort codes for the known values of each key
foreach my $si (keys %sortable_types) {
    if (${$typeinfo{$si}}{'reorder'}) {
	@{$keydata{$si}} = sort { &xmd_sort; } keys %{$valdefs{$si}};
    }
    my $i = 1;
    foreach my $v (@{$keydata{$si}}) {
#	print STDERR "$si:$v = $i\n";
	${$sortvals{$si}}{$v} = $i++;
	if (${$typeinfo{$si}}{'queryable'}) {
#	    print STDERR "$si:$v ? = $i\n";
	    ${$sortvals{$si}}{$v.' ?'} = $i++;
	}
    }
}

# dump sort values information
my $sortvals = "$results/sortvals.xml";
#my $sortvals_ = "@@ORACC@@/texts/lib/sortvals-.xml";
my $sortvals_ = "$xml/sortvals-.xml";
print STDERR "writing sortcodes to $sortvals\n" if $verbose;
open(SVI,">$sortvals") || die "$0: can't write to $sortvals. Stop.\n";
open(SVI_,">$sortvals_") || die "$0: can't write $sortvals_. Stop.\n";
print SVI '<?xml version="1.0" encoding="utf-8"?>',"\n";
print SVI '<sortvals>';
print SVI_ '<?xml version="1.0" encoding="utf-8"?>',"\n";
print SVI_ '<sortvals>';
foreach my $si (keys %sortable_types) {
    print SVI "<$si>";
    print SVI_ "<$si>" unless $si eq 'names';
#    foreach my $v (@{$keydata{$si}}) {
    foreach my $v (sort { ${$sortvals{$si}}{$a} <=> ${$sortvals{$si}}{$b} } 
		   keys %{$sortvals{$si}}) {
	my $refcount = ${$type_counts{$si}}{$v} || '0';
	my $c = xmlify(${$sortvals{$si}}{$v});
	my $xv = xmlify($v);
	print SVI "<v n=\"$xv\" c=\"$c\" r=\"$refcount\"/>";
	print SVI_ "<v n=\"$xv\" c=\"$c\"/>" unless $si eq 'names';
    }
    print SVI_ "</$si>" unless $si eq 'names';
    print SVI "</$si>";
}
print SVI '</sortvals>';
close(SVI);
print SVI_ '</sortvals>';
close(SVI_);

my $xmdfile = "$results/cdlicat.xmd";
if ($onebigfile) {
    my $splitmess = ($split ? "(and splitting) " : '');
    print STDERR "writing ${splitmess}XMD $xmdfile\n" if $verbose;
} else {
    print STDERR "writing XMD files " if $verbose;
}

my $total_rows = 0;
map { $total_rows += (1 + $#{ ${$$_{'icat'}}[2] }) } @catalogs;

#xmd_json_begin();
foreach my $c (@catalogs) {
    $proxying = ($$c{'file'} =~ /proxy/);
    dump_xmd($$c{'icat'},$$c{'file'});
}

if ($geojson_first < 0) {
    print GJ "]\n}\n";
    close GJ;
}
#xmd_json_end();

warn "$0: xmdfile = $xmdfile\n";
warn "$0: xmdsplit = $xmlsplit\n";

if ($onebigfile) {
    warn "$0: onebigfile\n" if $verbose;
    if (!$split) {
	if ($skip_xmd) {
	    # open(RS,">/dev/null");
	} else {
	    unless (open(XOUT,">$xmdfile")) {
		die "$0: can't write $xmdfile.\n";
	    }
	}
    } else {
	unless (open(XOUT,"|tee $xmdfile|$xmlsplit")) {
	    die "$0: can't write \|tee $xmdfile\|$xmlsplit.\n";
	}
    }
    select XOUT;
    print XOUT xmldecl();
    print XOUT "<xmd-set project=\"$project\">";
    foreach my $id (sort keys %xmd_outputs) {
	make_vid($id);
	print XOUT @{$xmd_outputs{$id}}; 
    }
    print XOUT '<?destfile?></xmd-set>';
    close(XOUT);
    if (scalar keys %valtab) {
	my $xproject = ($project ? $project : 'cdli');
	xsystem 'mkdir', '-p', "@@ORACC@@/pub/$project/cat";
	dump_vid("@@ORACC@@/bld/$project/cat/vid.dat");
	xsystem 'cp', '-p', "@@ORACC@@/bld/$project/cat/vid.dat", "@@ORACC@@/pub/$project/cat";
	xsystem 'cp', '-p', "@@ORACC@@/bld/$project/cat/proxy-xmd.map", "@@ORACC@@/pub/$project/cat";
	#FIXME: does this work with subprojects?
	xsystem "@@ORACC@@/bin/qcatx -s -p $xproject <$xmdfile";
	xsystem "@@ORACC@@/bin/pqxrecurse.plx $xproject";
	my $mangletab = "@@ORACC@@/pub/$project/cat/mangle.tab";
	system "sort -u -o $mangletab $mangletab";
#	xsystem 'gzip', '-f9', $xmdfile;
    }
}

print LOG '</log>';
close LOG;
warn "$0: closed $logfile\n" if $verbose;
#print KEYS '</keys>';
#close(KEYS);
sortkeys();

print VALTAB "#nmembers ", scalar(keys %valtab), "\n"; # $total_rows\n";
print VALTAB map { XIFY_P($valtab{$_}) } sort { XIFY_ID($a) <=> XIFY_ID($b) } keys %valtab;
print VALTAB "#nstring $stringpool_index\n";
foreach my $k (sort {$stringpool{$a} <=> $stringpool{$b} } keys %stringpool) {
    print VALTAB "$k\000";
}
close(VALTAB);

#open(V,'>01tmp/valtab.dump');
#print V Dumper \%valtab;
#close(V);

if (scalar keys %valtab) {
    warn "$0: processing valtab\n" if $verbose;
    # default to p4 pgcsix
    xsystem "@@ORACC@@/bin/pgcsix $results/sortinfo.tab";
    xsystem 'mv', "$results/sortinfo.csi", '02pub'
	if -r "$results/sortinfo.csi";
    if ($project eq 'cdli') {
	xsystem "@@ORACC@@/bin/catvec.plx";
    }
}
print STDERR "\n" if $verbose;

# format the log file
warn "$0: formatting log file\n" if $verbose;
my $lxsl = load_xsl($log_xsl);
my $lxml = load_xml($logfile);
my $lhtml = $lxsl->transform($lxml);
open(OUT,'>utf8',$loghtml) || die "xmdmanager.plx: can't write $loghtml\n";
#print OUT $lxsl->output_string($lhtml);
print OUT $lhtml->toString(1);
close(OUT);

########################################################

sub
XIFY_ID {
    my($p,$n) = ($_[0] =~ /^(.)(.*?)$/);
    if ($p eq 'X') {
	$n + 2000000;
    } elsif ($p eq 'Q') {
	$n + 3000000;
    } else {
	$n;
    }
}

sub
XIFY_P {
    my $tmp = shift;
    $tmp =~ s/(^|:)X/$1P2/;
    $tmp;
}

sub
badvalue {
    my($fieldname,$value) = @_;
    
#    print STDERR "$fieldname: unknown value $value [$count time$s]\n";
    my ($loc,$field) = ($fieldname =~ /^(.*?):(.*)$/);
    my $count = ${$value_counts{$field}}{$value} || 0;
    my $s = $count == 1 ? '' : 's';
    my $xf = xmlify($field);
    my $xv = xmlify($value);
    print LOG ORACC::Log::Util::entry(
	"$xf: unknown value $xv [$count time$s]",
	'error','field',{file=>$loc});
}

# walk the catalogs checking the values of interest and
# adding any new ones to the lists
sub
check_vals {
    my $cat = shift;
    my $fields = $$cat[0];
    my $rows = $$cat[2];
#    my $id_text = $$cat[3]; # not ready yet
    my @slice = ();
    my @sort_types= ();

    my %field_indexes = ();

    my $i = 0;
    foreach my $f (@$fields) {
	$field_indexes{$f} = $i++;
    }

    # cache the indices of the fields we care about
#    my @vtflds = ();
    $i = 0;
    foreach my $t (sort keys %sortable_types) {
	my $found = 0;
	foreach my $f (@{$fields_of_types{$t}}) {
	    if (defined $field_indexes{$f}) {
		push @slice, $field_indexes{$f};
		$sort_types[$field_indexes{$f}] = $typemap{$f};
		$found = 1;
		last;
	    }
	}
	if (!$found) {
	    push @slice, -1;
	}
	++$i;
    }
    warn("VALTAB fields @nvt\n") if $verbose;
    print VALTAB "#nfields $typindex\n", "#nmapentries $nvt_fields\n", @nvt unless $did_valtab++;
    # save these arrays for output time
    push @$cat, [@slice,-1], [@sort_types];
    foreach my $r (@$rows) {
	# check each sortable value in this row
	foreach my $i (@slice) {
	    next if $i < 0;
	    if ($$r[$i]) {
		if ($typeinfo{$typemap{$$fields[$i]}}{'queryable'}) {
		    unless ($$r[$i] eq '?') {
			$$r[$i] =~ s/\s*\?\s*$//; # && warn "$$r[$i] dequeried\n";
		    }
		}
		my ($f,$v,$t) = ($$fields[$i],$$r[$i],$sort_types[$i]);

		# This is a point at which we have each value for
		# each field available in turn; it might be good
		# to have generic field-hooks here ...
		if ($f eq 'period') {
		    $v =~ s/\s+\(.*$//;
		    # $v =~ s/Early Dynastic IIIb/Early Dynastic/;
		    if ($cat_merge_periods && $cat_merge_periods eq 'yes') {
#			warn "xmdmanager: merging periodizations\n";
			if ($merge_periods{$v}) {
#			    warn "merging $v => $merge_periods{$v}\n";
			    $v = $merge_periods{$v};
			} else {
			    if ($merge_periods_all{$v}) {
				# nothing to do here
			    } else {
				if ($v) {
				    warn "xmdmanager: $v: not in merge periods table\n";
				} else {
				    # need to warn here
				    $v = $merge_periods{'unknown'};
				}
			    }
			}
		    }
		    $$r[$i] = $v;
		}

		# Now handle bad values
		unless (defined ${$valdefs{$t}}{$v}) {
		    warn "no class for typeinfo{$t}\n" unless ${$typeinfo{$t}}{'class'};
		    if ('closed' eq ${$typeinfo{$t}}{'class'}) {
		        ++${$badvalues{$$locator{'file'}.':'.$f}}{$v};
		    }
		    unless (${$valdefs{$t}}{$v}++) {
			push @{$keydata{$t}}, $v;
		    }
		}
		++${$value_counts{$f}}{$v};
		++${$type_counts{$t}}{$v};
	    }
	}
    }
}

sub
dump_bad {
    foreach my $b (sort keys %badvalues) {
	foreach my $v (sort keys %{$badvalues{$b}}) {
#	    badvalue($b,$v,${$badvalues{$b}}{$v});
	    badvalue($b,$v);
	}
    }
}

sub
dump_images {
    my $id = shift;
    my $img = ($imgdoc ? $imgdoc->getElementsById($id) : undef);
    if ($img) {
	my $pub = ($pubimg{$id} ? 'yes' : 'no');
#	print "<images public=\"$pub\">", map({ $_->toString() } $img->childNodes()), '</images>';
	push @{$xmd_outputs{$curr_xmd}},
		"<images public=\"$pub\">", map({ $_->toString() } $img->childNodes()), '</images>';
    }
}

# walk the internalized data dumping the XMD and generating keys
sub
dump_xmd {
    my ($cat,$file) = @_;
    my $fields = $$cat[0];
    my $last = $#$fields;
    my $rows = $$cat[2];
    my $designation_index = -1;
    my $item_index = -1;
    my $xurl_index = -1;
    my $prov_index = -1;
    my $lang_index = -1;
    
    # determine the index of the field that has the P/Q number
    # for P this is id_text, for Q this is id_composite
    for (my $i = 0; $i <= $#$fields; ++$i) {
	$item_index = $i and last 
	    if $$fields[$i] =~ /^id_(?:text|composite)$/;
    }
    $item_index = -1 if $item_index > $#$fields;
    warn("xmdmanager: catalog $file has no id_text or id_composite field\n") and return
	unless $item_index >= 0;
    for (my $i = 0; $i <= $#$fields; ++$i) {
	$xurl_index = $i and last 
	    if $$fields[$i] eq 'xurl';
    }
    for (my $i = 0; $i <= $#$fields; ++$i) {
	$prov_index = $i and last 
	    if $$fields[$i] eq 'provenience';
    }
    for (my $i = 0; $i <= $#$fields; ++$i) {
	$lang_index = $i and last 
	    if $$fields[$i] eq 'language' || $$fields[$i] eq 'lang';
    }
    for (my $i = 0; $i <= $#$fields; ++$i) {
	$designation_index = $i and last 
	    if $$fields[$i] eq 'designation';
    }
    $lang_index = $item_index if $lang_index < 0;
#    print STDERR "lang_index = $lang_index; item_index = $item_index\n";

    my %slice_wanted = ();
    my @catslice = ();
    @catslice = @{$$cat[3]};
    @slice_wanted{ @catslice } = ();
    my @sort_types = @{$$cat[4]};
    my @sortrows = ();

#    if ($l2) {
#	map { make_vid($$_[$item_index]) } @$rows;
#	@sortrows = sort { $vid{$$a[$item_index]} 
#			   cmp $vid{$$b[$item_index]} } @$rows;
#	@sortrows = sort { $$a[$item_index] cmp $$b[$item_index] } @$rows;
#    } else {
#	@sortrows = sort { $$a[$item_index] cmp $$b[$item_index] } @$rows;
#    }

    # Note that we don't care about sort order any more because we build the
    # resultset in a hash and sort it on output
    foreach my $r (@$rows) {
	next unless $$r[$item_index];
	next unless $output_all || exists($output_records{$$r[$item_index]});
	next if $seen{$$r[$item_index]}++;
	next unless xmd_begin($$r[$item_index], $$r[$lang_index], $r);

	my $pleiades_id = undef; 
	my $coord = undef;

#	my @slice = @catslice;
#	for (my($i,$s) = (0,shift @slice); $i <= $last; ++$i) {
#	    while ($s == -1 && $#slice >= 0) {
#		$s = shift @slice;
#	    }
	for (my $i = 0; $i <= $last; ++$i) {
	    my $f = $$r[$i];
	    my $tag = $$fields[$i];
	    next if $tag eq 'images'; # always re-generate from images db
	    push @{$xmd_outputs{$curr_xmd}}, "<$tag";
	    if ($i == $#$fields && $f) {
		# this is the xproject field
		my $xuri;
		if ($xurl_index >= 0) {
		    $xuri = $$r[$xurl_index];
		}
		unless ($xuri) {
		    $xuri = $xproject_uris{$f};
		    $xuri .= "/$$r[$item_index]" if $f eq 'CDLI';
		}
		if ($xuri) {
		    $xuri = xmlify($xuri);
		    push @{$xmd_outputs{$curr_xmd}}, " uri=\"$xuri\"";
		}
	    }
	    if (exists $slice_wanted{$i}) { # $i == $s) {
		if ($f || ($i == $prov_index)) {
		    $f = 'unclear' unless $f;
		    my $c = ${$sortvals{$sort_types[$i]}}{$f};
		    my $sp = defined($stringpool{$f}) ? $stringpool{$f} 
		    : ($stringpool{$f} = $stringpool_index++);
		    my $tix = $type_indexes{$tag};
		    if (defined $tix) {
			if ($tag eq 'designation' && $project_designation_codes) {
			    my $id = $$r[$item_index];
			    if ($proj_des_sort{$id}) {
				$c = $proj_des_sort{$id};
				warn "Sortcode for $id == $c\n"
				    if $verbose;
			    } else {
				my($type) = ($id =~ /^([A-Z])/);
				warn "xmdmanager: no designation sortcode for $id=$$r[$designation_index]\n"
				    if $proj_des_sort{$type};
			    }
			}
			if ($c) {
			    $currvt[$type_indexes{$tag}] = "$c=$sp";
			    push @{$xmd_outputs{$curr_xmd}}, " c=\"$c\"";
			} else {
			    if ($f eq 'unclear') {
				$currvt[$type_indexes{$tag}] = "1000000=$sp";
				push @{$xmd_outputs{$curr_xmd}}, " c=\"1000000\"";
			    } else {
				print STDERR "c undefined for tag $tag with value $f\n";
			    }
			}
		    } else {
			print STDERR "type_indexes{$tag} not defined (value=$f)\n" 
			    unless $tix_warned{$tag}++;
		    }
		} else {
		    $currvt[$type_indexes{$tag}] = "1000000=0";
		    push @{$xmd_outputs{$curr_xmd}}, " c=\"1000000\"";
		}
#		$s = shift @slice;
	    }
	    if ($f) {
		if ($f =~ / \000 /) {
		    push @{$xmd_outputs{$curr_xmd}}, '>';
		    foreach my $fbit (split(/ \000 /,$f)) {
			my $xf = xmlify($fbit);
			push @{$xmd_outputs{$curr_xmd}}, "<subfield>$xf</subfield>";
#			findex($tag,$fbit) unless exists $nifs{$tag};
		    }
		    push @{$xmd_outputs{$curr_xmd}}, "</$tag>";
		} else {
		    my $xf = xmlify($f);
		    $xf =~ s/\&amp;(apos|lt|gt|quot)/\&$1/g; # suppress double-xmlify effects
#		    if ($tag eq 'period') {
#			$xf =~ s/\s+\(.*$//; # remove CDLI dates-on-periods
#			if ($cat_merge_periods) {
#			    if ($merge_periods{$xf}) {
#				$xf = $merge_periods{$xf};
#			    } else {
#				warn "$xf: not in merge periods table\n";
#			    }
#			} else {
#			    # This is a legacy op; not sure it's necessary any more
#			    if ($curr_xmd =~ /^Q/) {
#				# should really map P-periods to Q-periods more generically
#				$xf =~ s/Early Dynastic IIIb/Early Dynastic/;
#			    }
#			}
#		    }
		    push @{$xmd_outputs{$curr_xmd}}, ">$xf</$tag>";
#		    findex($tag,$f,$xf) unless exists $nifs{$tag};
		}
	    } else {
		push @{$xmd_outputs{$curr_xmd}}, '/>';
	    }
	    if ($i == $prov_index && $cat_pleiades) {
		$pleiades_id = ORACC::XMD::Pleiades::pleiades_id($$r[$item_index],
		    $f, @pleiades_data);
		if ($pleiades_id) {
		    $coord = ORACC::XMD::Pleiades::coords($pleiades_id, @pleiades_data);
		    push @{$xmd_outputs{$curr_xmd}}, 
		    "<pleiades_id>$pleiades_id</pleiades_id>";
		    if ($coord) {
			push @{$xmd_outputs{$curr_xmd}}, 
			"<pleiades_coord>$coord</pleiades_coord>";
		    }
		    xmd_geojson($fields, $r, $pleiades_id, $coord) 
			if $pleiades_id && $coord;
		}
	    }
	}
#	xmd_json_item($fields, $r, $item_index, 
#		      $prov_index, $pleiades_id, $coord);
	for (my $ti = 0; $ti < $typindex; ++$ti) {
	    $currvt[$ti] = "1000000=0" unless $currvt[$ti];
	}
#	print Dumper(\@currvt);
	xmd_end($$r[$item_index]);
    }
}

sub
find_keydata {
    my $catproj = shift || 'cdli';
    if (-r '00lib/keydata.xml') {
	$project_mode = 1;
	$keydata = '00lib/keydata.xml';
    } elsif (($keydata = find_keydata_in_parent($project))) {
	; # do nothing, we set $keydata in the conditional test
    } elsif (-r "@@ORACC@@/pub/$catproj/keydata.xml") {
	$keydata = "@@ORACC@@/pub/$catproj/keydata.xml";
    } else {
	$keydata = "@@ORACC@@/lib/data/keydata.xml";
    }
    warn "xmdmanager2.plx: using keydata from $keydata\n";
    $keydata;
}

sub find_keydata_in_parent {
    my $p = shift;
    warn "find_key_data_in_parent: arg p = $p\n";
    while ($p =~ s#/[^/]+$##) {
	warn "find_key_data_in_parent: trying $p\n";
	if (-r "@@ORACC@@/$p/00lib/keydata.xml") {
	    warn "find_key_data_in_parent: found $p/00lib/keydata.xml\n";
	    return "@@ORACC@@/$p/00lib/keydata.xml";
	}
    }
    '';
}

#sub
#findex {
#    my ($tag,$f,$xf) = @_;
#    $xru{$f} = xmlify(ORACC::XRU::Canonicalize::str($f))
#	unless exists $xru{$f};
#    $c14n{$tag} = $xru{$f};
#    $orig{$xru{$f}} = $xf;
#}

sub
imports {
    my $cat = shift;
    my $fields = $$cat[0];
    my %fields = %{$$cat[1]};
    my $rows = $$cat[2];
    my @inherits = ();
    my %via_indexes = ();

    foreach my $n (tags($kdoc,$kd_uri,'imported')) {
	foreach my $f (tags($n,$kd_uri,'field')) {
	    my $fn = $f->getAttribute('n');
	    my $via = $f->getAttribute('via');
	    my $fn_index = -1;
	    # find the field index for this entry, if any
	    for (my $i = 0; $i <= $#$fields; ++$i) {
		$fn_index = $i and last 
		    if $$fields[$i] eq $fn;
	    }
	    if (-1 == $fn_index) {
#		print STDERR "adding $fn\n";
		push @$fields, $fn;
		$fn_index = $fields{$fn} = $#$fields;
	    }
	    unless ($via_indexes{$via}) {
		my $via_index = -1;
		for (my $i = 0; $i <= $#$fields; ++$i) {
		    $via_index = $i and last 
			if $$fields[$i] eq $via;
		}
		$via_indexes{$via} = $via_index;
	    }
	    push (@inherits,
		  [ $fn_index, undef, $fn, $via_indexes{$via} ]);
	}
    }

    $$cat[0] = $fields;
    $$cat[1] = { %fields };

    foreach my $r (@$rows) {
	foreach my $i (@inherits) {
	    # first edit the cache to replace $$i[1] with the row-specific value
	    # derived from $$i[3]
	    $$i[1] = $$r[$$i[3]];
	    unless ($$r[$$i[0]]) {
		$$r[$$i[0]] 
		    = ORACC::XMD::Fields::get_field_in_project('cdli',
							       $$i[1],
							       $$i[2]);
#		$$r[$$i[0]] = ORACC::XMD::Fields::get_field($$i[1],$$i[2]);
	    }
	}
    }
    $cat;
}

sub
inherits {
    my $cat = shift;
    my $fields = $$cat[0];
    my %fields = %{$$cat[1]};
    my $rows = $$cat[2];
    my @inherits = ();
    my %via_indexes = ();

#    print STDERR "fields = @$fields\n";

    # for each inherit node cache the attributes
    foreach my $n (tags($kdoc,$kd_uri,'inherited')) {
	foreach my $f (tags($n,$kd_uri,'field')) {
	    my $fn = $f->getAttribute('n');
	    my $newok = $f->getAttribute('new');
	    my $via = $f->getAttribute('via');
	    my $fn_index = -1;

	    # find the field index for this entry
	    for (my $i = 0; $i <= $#$fields; ++$i) {
#		print STDERR "fn=$fn; field $i = $$fields[$i]\n";
		$fn_index = $i and last 
		    if $$fields[$i] eq $fn;
	    }
	    if ($fn_index >= 0 || $newok) {
		if ($fn_index == -1) {
		    push @$fields, $fn;
		    $fn_index = $fields{$fn} = $#$fields;
		}
		unless ($via_indexes{$via}) {
		    my $via_index = -1;
		    for (my $i = 0; $i <= $#$fields; ++$i) {
			$via_index = $i and last 
			    if $$fields[$i] eq $via;
		    }
		    $via_indexes{$via} = $via_index;
		}
		push (@inherits,
		      [ $fn_index, undef, $f->getAttribute('from'), $via_indexes{$via} ]);
	    } else {
		warn("$fn: field name in inherits not in catalogue\n");
	    }
	}
    }

    $$cat[0] = $fields;
    $$cat[1] = { %fields };
   
    foreach my $r (@$rows) {
	foreach my $i (@inherits) {
	    # first edit the cache to replace $$i[1] with the row-specific value
	    # derived from $$i[3]
	    $$i[1] = $$r[$$i[3]];
	    unless ($$r[$$i[0]]) {
		$$r[$$i[0]] = ORACC::XMD::Fields::get_field($$i[1],$$i[2]);
	    }
	}
    }

    $cat;
}

sub cat_master {
    my $p = $project;
    my $cat_master = '';
    while (1) {
	if (-r "$ENV{'ORACC_BUILDS'}/$p/00lib/config.xml") {
	    $cat_master = `oraccopt $p catalog-master-project`;
	}
	last if $cat_master;
	last unless $p =~ s#/[^/]+##;
    }
    my @c = split(/\s+/,$cat_master);
    if ($c[1]) {
	$cat_master = shift @c;
	@cat_masters = @c;
    }
    warn "$0: found cat-master $cat_master\n" if $cat_master;
    $cat_master;
}

sub
make_dynacat {
    my @todo = @_;
    my $cat_list = `oraccopt . catalog-build-list`;
    my $cat_master = cat_master();

    if ($cat_list) {
	die "$0: config.xml's catalog-build-list = $cat_list is unreadable or missing. Stop.\n"
	    unless -r $cat_list;
    }
    my $list = $cat_list || '01bld/lists/approved.lst';
    my $pcat = "01bld/cat/dynamic-p.xml";
    my $qcat = "01bld/cat/dynamic-q.xml";
    my $n_p = 0;
    my $n_q = 0;

    warn ("xmdmanager: creating $pcat/$qcat dynamically from $list ...\n") if $verbose;
    open(P,">$pcat") || die "xmdmanager: unable to open `$pcat'\n";
    open(Q,">$qcat") || die "xmdmanager: unable to open `$qcat'\n";
    print P xmldecl();
    print Q xmldecl();
    print P '<catalog xmlns="http://oracc.org/ns/xmd/1.0">';
    print Q '<catalog xmlns="http://oracc.org/ns/xmd/1.0">';
    my @lst = ();
    if ($#todo >= 0) {
	@lst = @todo;
    } else {
	if (-r $list) {
	    open(L,$list);
	    @lst = (<L>); chomp(@lst);
	    close(L);
	} else {
	    warn "$0: proceeding without $list.\n";
	}
    }
    local($/) = undef;
    my @trylist = ();
    if ($cat_master) {
	# cat_master is exclusive--if you use it you have to provide it with all the data
	# you want in it, or give additional cats to search in the cat_master option
	push (@trylist, $cat_master);
	push (@trylist, @cat_masters) if $#cat_masters >= 0;
    } else {
	push @trylist, 'cdli', 'qcat', 'xcat';
    }
    foreach my $f (@lst) {
	my $xf = '';
	$f =~ tr/\n\r//d;
	next unless length $f;
	next if $f =~ /(?:^|:)X/;
	my $xmd = '';
	my $proj = undef;
	foreach my $p (@trylist) {
	    $xf = $f;
	    $xf =~ s/^.*?://;
	    $proj = $p;
	    $xmd = expand_in_project(undef,"$xf.xmd",$p);
	    $xmd = '' unless $xmd;
	    warn "expand_in_project(undef,$xf.xmd,$p)=>$xmd\n"
		if $verbose;
	    if ($xmd && -r $xmd) {
		last;
	    } else {
		$xmd = '';
	    }
	}
	unless ($xmd) {
	    warn "xmdmanager2.plx: (dynamic) no catalogue information for '$xf' found in @trylist\n";
	    ++$skip_list{$xf};
	    next;
	}
	$id_projects{$xf} = $project;
	open(X,$xmd);
	$_ = <X>;
	close(X);
	s/^\<\?xml.*?>\s*\n//;
	if (/\?xml/) {
	    warn("$xmd: leftover XML decl\n");
	}
	s/^\<xmd.*?<cat>/<record>/;
#	s,<images>.*?</images>,,;
	s,</cat></xmd>,</record>,;
	if ($f =~ /(?:^|:)P/) {
### replace \n\r with space is TEMPORARY UNTIL FXR/XMD IMPORT STRIPS THESE; 
### deleting \000 may be permanent to trap stray UTF-16 which passes jsonlint
### but chokes python json decoding
	    tr/\n\r\000/  /;
	    print P $_;
	    ++$n_p;
	} else {
	    print Q $_;
	    ++$n_q;
	}
    }
    close(L);
    print P "</catalog>"; close(P);
    print Q "</catalog>"; close(Q);
    ## FIXME: need to validate X-numbers if project-x is used instead of xcat
    xsystem 'xcat.plx' unless -e "00cat/$project-x.xml";
    unlink $pcat unless $n_p;
    unlink $qcat unless $n_q;
    ## Note that we do not edit project-x.xml; only edit cats that are in 01bld/cat
    if (-r "00bin/edit-dynacat.sh") {
	foreach my $c ($pcat, $qcat, '01bld/cat/dynamic-x.xml') {
	    xsystem('00bin/edit-dynacat.sh', $c) if -r $c;
	}
    }
    foreach my $c ($pcat, $qcat, '01bld/cat/dynamic-x.xml', "00cat/$project-x.xml") {
	push(@catalogs , { 'file'=>$c }) if -r $c;
    }
}

# virtual cat is only an option when there is no xtf
# in the project, otherwise use dynamic
sub
make_vcat {
    my $d = shift;
    my $cat_list = `oraccopt . catalog-build-list`;

    # Now that there are separate 01bld/cat/proxy-[pqx].xml we default
    # to using 00lib/proxy.lst but this can be overridden using
    # catalog-build-list
    my $list = $cat_list || '00lib/proxy.lst';

    return unless $list && -s $list;

    my $pcat = "01bld/cat/dynamic-p.xml";
    my $qcat = "01bld/cat/dynamic-q.xml";
    my $xcat = "01bld/cat/dynamic-x.xml";
    my $proj = '';
    my $n_p = 0;
    my $n_q = 0;
    my $n_x = 0;

    warn ("xmdmanager: creating $pcat/$qcat virtually from $list ...\n") 
	if $verbose;
    open(P,">$pcat") || die "xmdmanager: unable to open `$pcat'\n";
    open(Q,">$qcat") || die "xmdmanager: unable to open `$qcat'\n";
    open(X,">$xcat") || die "xmdmanager: unable to open `$xcat'\n";
    print P xmldecl();
    print Q xmldecl();
    print X xmldecl();
    print P '<catalog xmlns="http://oracc.org/ns/xmd/1.0">';
    print Q '<catalog xmlns="http://oracc.org/ns/xmd/1.0">';
    print X '<catalog xmlns="http://oracc.org/ns/xmd/1.0">';
    open(L,$list) || die;
    my @lst = (<L>); chomp(@lst);
    close(L);
    local($/) = undef;
    my @trylist = ();
    push @trylist, 'cdli', 'qcat';
    foreach my $f (@lst) {
	$f =~ tr/\cM//d;
	next unless $f;
	my $xmd = '';
#	if ($f =~ s/^(.*?):(.*?)\@(.*?)$/$2/) {
#	    my $xmd_proj = '';
#	    ($proj,$xmd_proj) = ($1,$3);
#	    $xmd = expand_in_project(undef,"$f.xmd",$xmd_proj);
#	    warn "no metadata for $f found in $xmd_proj\n" 
#		and next unless -r $xmd;
	#	} else {
	my @xtrylist = @trylist;
	if ($f =~ s/^(.*?):(.*?)\@(.*?)$/$2/) {
	    unshift @xtrylist, $3;
	} else {
	    $f =~ s/^(.*?)://; # reduce to PQX;
	    push @xtrylist, $1;
	}
	foreach my $p (@xtrylist) {
	    $proj = $p;
	    $xmd = expand_in_project(undef,"$f.xmd",$p);
	    last if $xmd && -r $xmd;
	}
	warn "no metadata for $f found in @xtrylist\n" 
	    and next unless -r $xmd;
	$proj = $project;
#	}
	$id_projects{$f} = $proj;
	open(XMD,$xmd);
	$_ = <XMD>;
	close(XMD);
	s/^\<\?xml.*?>\s*\n//;
	if (/\?xml/) {
	    warn("$xmd: leftover XML decl\n");
	}
	s/^\<xmd.*?<cat>/<record project=\"$proj\">/;
#	s,<images>.*?</images>,,;
	s,</cat></xmd>,</record>,;
	if ($f =~ /(?:^|:)P/) {
	    tr/\n\r/  /; ### TEMPORARY UNTIL FXR/XMD IMPORT STRIPS THESE
	    print P $_;
	    ++$n_p;
	} elsif ($f =~ /(?:^|:)Q/) {
	    print Q $_;
	    ++$n_q;
	} else {
	    print X $_;
	    ++$n_x;
	}
    }
    close(L);
    print P "</catalog>"; close(P);
    print Q "</catalog>"; close(Q);
    print X "</catalog>"; close(X);
    unlink $pcat unless $n_p;
    unlink $qcat unless $n_q;
    unlink $xcat unless $n_x;

    foreach my $c ($pcat, $qcat, $xcat) {
	push(@catalogs , { 'file'=>$c }) if -r $c;
    }
}

sub
make_vid {
    my $pqx = shift;
    if ($pqx =~ /(?:^|:)P(\d+)$/ && length($1) != 6) {
	my $nid = $1;
	$nid = 'P'.('0'x(6-length($nid))).$nid;
	print STDERR "xmdmanager: repairing P-ID from $pqx to $nid\n"
	    if $verbose;
	if ($pqx =~ /:/) {
	    $pqx =~ s/:.*$/:$nid/;
	} else {
	    $pqx = $nid;
	}
    }
    $pqx =~ s/^.*?://;
    push @vid, $pqx;
    $vid{$pqx} = $#vid;
}

sub
qualify_vid {
    my $id = shift;
    my $xtf = $id_projects{$id,'xtf'} || $project;
    my $xmd = $id_projects{$id,'xmd'} || $project;
    print XMDMAP "$xtf:$id\t$xmd\n";
    if ($xtf ne $xmd) {
	"$xtf\@$xmd:$id";
    } else {
	"$xtf:$id";
    }
}

sub
vid_pad {
    my($s,$n) = @_;
    $s.("\000"x($n - length($s)));
}

# Format of vid.dat is:
#
# [NUMBER_OF_ENTRIES]
# [LENGTH_OF_ENTRY]
# [PROJECT_FOR_XTF_AND_XMD]:[PQXID] | [PROJECT_FOR_XTF]@[PROJECT_FOR_XMD]:[PQXID]
#
sub
dump_vid {
    xsystem 'mkdir', '-p', '01bld/cat';
    open(XMDMAP, ">01bld/cat/proxy-xmd.map");
    open(V,">$_[0]") || die "dump_vid: can't open '$_[0]'\n";
    my @qvid = map { qualify_vid($_) } @vid;
    my $max = max_vid_len(@qvid);
    printf V "%d\000%d\000", $#vid+1, $max;
    foreach my $qvid (@qvid) {
	print V vid_pad($qvid,$max);
    }
    close(V);
    close(XMDMAP);
}

sub
max_vid_len {
    my $len = 0;
    foreach (@_) {
	$len = length if length > $len;
    }
    $len+1;
}

sub
open_tab_files {
    open(LOCTAB,">$public/place.tab");
    open(PERTAB,">$public/period.tab");
    open(MUSTAB,">$public/musnos.tab");
    open(PRITAB,">$public/pripub.tab");
    open(PNMTAB,">$public/Pnames.tab");
    open(QNMTAB,">$public/Qnames.tab");
    open(PUBIMG,">$public/public_image.lst");
    open(PRVIMG,">$public/private_image.lst");
    open(VALTAB,">$results/sortinfo.tab");
}

sub
remap {
    my $cat = shift;
    my $fields = $$cat[0];
    my $remap_type = undef;
    my $remap_to = undef;
    my $remap_index = -1;
    my $remap_source = -1;

    # does any field in this catalog have a field type which is remappable?
    for (my $i = 0; $i <= $#$fields; ++$i) {
	if ($typemap{$$fields[$i]}) {
	    if (${$typeinfo{$typemap{$$fields[$i]}}}{'remap'}) {
		$remap_type = $typemap{$$fields[$i]};
		$remap_source = $i;
		$remap_to = ${$typeinfo{$remap_type}}{'node'}->getAttribute('remap-to');
		last;
	    }
	}
    }

    return unless $remap_type;

    # does the remap target exist as a field in this catalog?
    if ($remap_to) {
	for (my $i = 0; $i <= $#$fields; ++$i) {
	    if ($remap_to eq $$fields[$i]) {
		$remap_index = $i;
	    }
	}
    }
    # if not, append it to the field list
    if ($remap_index == -1) {
	$remap_index = $#$fields+1;
	push @$fields, $remap_to;
    }
    # build a hash of remap values unless we have it already
    my %remap = get_remaps($remap_type);

    # traverse the data rows creating the remap fields
    my $rows = $$cat[2];
    foreach my $r (@$rows) {
	if ($$r[$remap_source]) {
	    my $v = $$r[$remap_source];
	    $v =~ s/\s*\?\s*$//;
	    my $as;
	    if ($remap{$v}) {
		$as = $remap{$v};
	    } else {
#		print LOG ORACC::Log::Util::entry(
#		    "$remap_to: no remap for value '$v'",
#		    'error','field',{})
		print STDERR "$remap_to: no remap for value '$v'\n"
		    unless $badremaps{$v}++;
		$as = 'unknown';
	    }
	    $$r[$remap_index] = $as;
	}
    }
}

sub
get_remaps {
    my $type = shift;
    unless ($remaps{$type}) {
	my %map = ();
	foreach my $v (tags(${$typeinfo{$type}}{'node'},$kd_uri,'val')) {
	    $map{$v->getAttribute('n')} = $v->getAttribute('remap');
	}
	$remaps{$type} = { %map };
    }
    %{$remaps{$type}};
}

sub
cat_hack_file {
    my $cat = shift;
    my($p,$f) = (split(/:/,$cat));
    my $catfile = "$ENV{'ORACC'}/$p/02pub/$f";
    return ( 'project'=>$p, 'file'=>$catfile );
}

sub
cat_keydata {
    my $K = '';
    my $Kproj = '';
    foreach my $c (@catalogs) {
	my $k = find_keydata($$c{'project'});
	if ($k ne $K) {
	    if ($K) {
		warn "xmdmanager: incompatible keydata between projects $Kproj and $$c{'project'}\n";
	    } else {
		$K = $k;
		$Kproj = $$c{'project'};
	    }
	}
    }
    $K;
}

sub
setup_derived_cat {
#  e.g., saao:saa_cat.xml,xcat.xml
#  or    xcat.xml,saao:saa_cat.xml
    my @catfiles = split(',',
			 `oraccopt . catalog-sysfiles`);
#    @catfiles = map { cat_hack_file($_) } @catfiles;
#    @catalogs = map { { ('project','file') = split(/:/,$_) } } @catfiles;
    @catalogs = map { { cat_hack_file($_) } } @catfiles;

    $keydata = cat_keydata(@catalogs);

    ### set list of files to restrict output here
    if (open(A,'01bld/lists/approved.lst')) {
	my @a = (<A>); chomp(@a);
	@output_records{ map { s/^.*?://; $_ } @a } = ();
	close(A);
	$output_all = 0;
    }
}

# not presently used b/c we should really require the DB to be
# clean
sub
stripwhite {
    return '' unless $_[0];
    my $qry = ($_[0] =~ tr/?//d) ? '?' : '';
    $_[0] =~ s/^\s*//;
    $_[0] =~ s/\s*$//;
    $_[0].$qry;
}

sub
type_from_ns {
    my $fn = shift;
    if ($fn =~ /\.csv$/) {
	'csv';
    } elsif ($fn =~ /\.tsv$/) {
	'tsv';
    } else {
	my $ns = `@@ORACC@@/bin/xmlns $fn`;
	if ($ns_types{$ns}) {
	    $ns_types{$ns};
	} else {
	    die "xmdmanager.plx: xmlns `$ns' is not a known catalogue type\n";
	}
    }
}

sub
xmd_begin {
    my ($id,$langs,$row) = @_;
    # This is a hack to handle 2013-vintage CDLI mysql db output
    if ($id =~ /^\d/) {
 	$id = "P$id";
    }
    if ($id !~ /^[PQX]\d\d\d\d\d\d$/) {
	if ($id =~ /^P(\d+)$/) {
	    my $nid = $1;
	    $nid = 'P'.('0'x(6-length($nid))).$nid;
	    print STDERR "xmdmanager: repairing P-ID from $id to $nid\n"
		if $verbose;
	    $id = $nid;
	} else {
	    my @data = grep (defined && length , @$row);
	    print STDERR "xmdmanager: bad ID `$id'\n data=@data\n";
	    return 0;
	}
    }

    my $xmd = $id;

    $curr_xmd = $xmd;

    my $langmask = 0;
    if ($langs && $langs ne $id) {
	$langs =~ s/\s*\?\s*//g;
	foreach my $l (split(/[, ]/,$langs)) {
	    $l = "\l$l";
	    if ($langmasks{$l}) {
		$langmask |= $langmasks{$l};
	    } else {
		++$unknown_langs{$l};
		$langmask |= $langmasks{'misc'};
	    }
	}
	$lmattr = sprintf(" langs=\"0x%08x\"", $langmask);
#	print STDERR "lmattr = $lmattr\n";
    } else {
	$lmattr = "";
    }

    my($pref) = ($id =~ /^(....)/);

    if ($proxying) {
#	print '<?destfile #none?>';
	push @{$xmd_outputs{$curr_xmd}}, '<?destfile #none?>';
    } else {
#	print "<?destfile @@ORACC@@/$project/01bld/$pref/$id/$id.xmd?>";
	push @{$xmd_outputs{$curr_xmd}}, "<?destfile @@ORACC_BUILDS@@/$project/01bld/$pref/$id/$id.xmd?>";
    }

    my $xlink = '';
    my $xp = $xproject{$id} || '';
    if ($xp eq 'CDLI' || ($xp eq 'DCCLT' && $id =~ /(?:^|:)P/)) {
	$xlink = "http://cdli.ucla.edu/$id";
    } elsif ($xp eq 'ETCSL') {
	;
    }
    if (!$onebigfile) {
	print '<?xml version="1.0" encoding="utf-8"?>',"\n";
    }
    my $pattr = '';
    if ($id_projects{$id,'xtf'}) {
	$pattr = " project=\"$id_projects{$id,'xtf'}\"";
    } else {
	$pattr = " project=\"$project\"";
    }
#    print "<xmd xmlns=\"$XMD\" xmlns:xmd=\"$XMD\" xml:id=\"$id\"$lmattr$pattr><cat>";
    push @{$xmd_outputs{$curr_xmd}}, "<xmd xmlns=\"$XMD\" xmlns:xmd=\"$XMD\" xml:id=\"$id\"$lmattr$pattr><cat>";
    1;
}

sub
xmd_end {
    my $id = shift;

    if ($id =~ /^\d/) {
	my $nid = $id;
	$id = sprintf("P%06d", $id);
    }
#    print VALTAB "\n";
    
    $valtab{$id} = join("\t",$id,@currvt)."\n";
#    warn "$id => $valtab{$id}";
    @currvt = ();
    dump_images($id);

    ### This is where to insert extra fields
    dump_translist($id);
    
#    extra_meta($id);

#    print '</cat>';
#    print "</xmd>";
    push @{$xmd_outputs{$curr_xmd}}, '</cat></xmd>';
#    if ($id =~ /^P/ && scalar keys %c14n) {
#	my($pref) = ($id =~ /^(....)/);
#	print KEYS "<key ref=\"$id\"$lmattr>";
#	foreach my $if (keys %c14n) {
#	    print KEYS "<$if>$c14n{$if}</$if>";	    
#	}
#	print KEYS '</key>';
#    } elsif ($id =~ /^Q/ && scalar keys %c14n) {
#	print KEYS "<key ref=\"$id\"$lmattr>";
#	foreach my $if (keys %c14n) {
#	    print KEYS "<$if>$c14n{$if}</$if>";	    
#	}
#	print KEYS '</key>';
#    }
#    %c14n = ();
}

sub
uniq {
    my %x;
    @x{@_} = ();
    sort keys %x;
}

sub
splitkeys {
    my @res = ();
    my $tmp = $_[0];
    $tmp =~ tr/a-zA-Z0-9 .//cd;
    foreach my $r (split(/[\s\.]+/, $tmp)) {
	my $r2 = undef;
	my $intval = 0;
	if ($r =~ /^\d/) {
	    if ($r =~ /^\d+$/) {
		$intval = 1;
	    } else {
		$r =~ s/^(\d+)(.*)$/$1/;
		$r2 = $2;
		$intval = 2;
	    }
	}
	my $tmp = [ $intval , $r , $r2 ];
	push @res, $tmp;
    }
    $split_sortkeys{$_[0]} = [@res];
    @res;
}

# FIXME: we should do a multilevel cmp here on unaccented then NFD; also alph vs num
# keys
sub
xmd_sort {
    my $ret = 0;
    my @a = ();
    my @b = ();
    if ($split_sortkeys{$a}) {
	@a = @{$split_sortkeys{$a}};
    } else {
	@a = splitkeys($a);
    }
    if ($split_sortkeys{$b}) {
	@b = @{$split_sortkeys{$b}};
    } else {
	@b = splitkeys($b);
    }
    # @a and @b are now lists of doubles [ intflag , value ]
    # intflag is 1 if the value is entirely numeric
    for (my $i = 0; $i <= $#a && $i <= $#b; ++$i) {
	if (${$a[$i]}[0]) {
	    if (${$b[$i]}[0]) {
		$ret = ${$a[$i]}[1] <=> ${$b[$i]}[1];
		if (0 == $ret) {
		    if (${$a[$i]}[0] == 2) {
			if (${$b[$i]}[0] == 2) {
			    $ret = ${$a[$i]}[2] cmp ${$b[$i]}[2];
			} else {
			    $ret = 1;
			}
		    } elsif (${$b[$i]}[0] == 2) {
			$ret = -1;
		    }
		}
	    } else {
		$ret = -1;
	    }
	} elsif (${$b[$i]}[0]) {
	    $ret = 1;
	} else {
	    $ret = ${$a[$i]}[1] cmp ${$b[$i]}[1];
	}
	return $ret if $ret;
    }
    # default to sorting on length:
    # if we got here and they are the same length, return 0
    # if a is shorter ret is negative; if b is shorter, a is positive
    $#a <=> $#b;
}

# walk the catalogs checking the values of interest and
# adding any new ones to the lists
sub
xproject {
    my ($cat,$file) = @_;
    my $fields = $$cat[0];
    my $rows = $$cat[2];
    my $item_index = -1;
    my $name_index = -1;
    my $period_index = -1;
    my $place_index = -1;
    my $pripub_index = -1;
    my $pubimg_index = -1;
    my @musno_indices = ();
    my %musno_fields = ();
    @musno_fields{qw/excavation_no museum_no accession_no/} = ();

    # find the ID field for this catalog
    for (my $i = 0; $i <= $#$fields; ++$i) {
	$item_index = $i and last 
	    if $$fields[$i] =~ /^id_(?:text|composite)$/;
    }
    $item_index = -1 if $item_index > $#$fields;

    # find the period field for this catalog
    for (my $i = 0; $i <= $#$fields; ++$i) {
	$period_index = $i and last 
	    if $$fields[$i] eq 'period';
    }
    # find the place field for this catalog
    for (my $i = 0; $i <= $#$fields; ++$i) {
	$place_index = $i and last 
	    if $$fields[$i] eq 'provenience';
    }
    # find the public_images field for this catalog
    for (my $i = 0; $i <= $#$fields; ++$i) {
	$pubimg_index = $i and last 
	    if $$fields[$i] eq 'public_images';
    }

    warn("xmdmanager: xproject: catalog $file has no id_text or id_composite field\n") and return
	unless $item_index >= 0;

    # if it is the main cat, we will dump ID:NAME table here also
 #   if (${$$rows[0]}[$item_index] =~ /^P/) {
	for (my $i = 0; $i <= $#$fields; ++$i) {
#	    warn "x: trying $$fields[$i]\n" if $file =~ /-x/;
	    $name_index = $i and last 
		if $$fields[$i] eq 'designation';
	}
	$name_index = -1 if $name_index > $#$fields;
	warn("xmdmanager: catalog $file lacks required designation field\n") and return
	    unless $name_index >= 0;
	for (my $i = 0; $i <= $#$fields; ++$i) {
	    if ($$fields[$i] eq 'primary_publication') {
		$pripub_index = $i;
	    } elsif (exists $musno_fields{$$fields[$i]}) {
		push @musno_indices, $i;
	    }
	}
#    } else {
#	for (my $i = 0; $i <= $#$fields; ++$i) {
#	    $name_index = $i and last 
#		if $$fields[$i] eq 'name';
#	}
#    }
    my $xprojects_index = $#$fields+1;
    push @$fields, 'xproject';

    foreach my $r (@$rows) {
	my $pq = $$r[$item_index];
	next unless $pq;
	if ($$r[$period_index]) {
	    print PERTAB "$pq\t$$r[$period_index]\n";
	} else {
	    print PERTAB "$pq\tunknown\n";
	}
	my $pl = $$r[$place_index] || 'unknown';
	print LOCTAB "$pq\t$pl\n";
	if ($pq =~ /(?:^|:)P/) {
	    my $pname = $$r[$name_index];
	    if ($pname) {
		$pname =~ s/^\s*(.*?)\s*$/$1/;
		$pname =~ s/&apos;/'/g;
		$pname =~ s/&amp;/&/g;
	    } else {
		$pname = '';
	    }
	    $$r[$xprojects_index] = $xproject{$pq} || 'CDLI';
	    print PNMTAB "$pq\t$pname\n";
	    print PRITAB "$pq\t", strip0($$r[$pripub_index]),"\n"
		if $$r[$pripub_index];
	    foreach my $m (@musno_indices) {
		print MUSTAB "$pq\t",strip0($$r[$m]),"\n"
		    if $$r[$m];
	    }
	    if ($pubimg_index >= 0 && $$r[$pubimg_index] && $$r[$pubimg_index] eq 'yes') {
		print PUBIMG "$pq\n";
		++$pubimg{$pq};
	    } else {
		print PRVIMG "$pq\n";
	    }
	} else {
	    my $qname = $$r[$name_index];
#	    warn "printing $pq\t$qname to QNMTAB\n";
	    print QNMTAB "$pq\t$qname\n" if $pq =~ /(?:^|:)Q/;
	    $$r[$xprojects_index] = $xproject{$pq} || '';
	}
    }
}

# walk the catalogs checking the values of interest and
# adding any new ones to the lists
#
# This version is used by projects that have their own keydata.xml
sub
xproject_bis {
    my ($cat,$file) = @_;
    my $fields = $$cat[0];
    my $rows = $$cat[2];
    my $item_index = -1;
    my $name_index = -1;
    my $period_index = -1;
    my $place_index = -1;
    my $pripub_index = -1;
    my $pubimg_index = -1;
    my @musno_indices = ();
    my %musno_fields = ();
    @musno_fields{qw/excavation_no museum_no accession_no/} = ();

    # find the ID field for this catalog
    for (my $i = 0; $i <= $#$fields; ++$i) {
	$item_index = $i and last 
	    if $$fields[$i] =~ /^id_(?:text|composite)$/;
    }
    $item_index = -1 if $item_index > $#$fields;

    # find the period field for this catalog
    for (my $i = 0; $i <= $#$fields; ++$i) {
	$period_index = $i and last 
	    if $$fields[$i] eq 'period';
    }
    # find the place field for this catalog
    for (my $i = 0; $i <= $#$fields; ++$i) {
	$place_index = $i and last 
	    if $$fields[$i] eq 'provenience';
    }
    # find the public_images field for this catalog
    for (my $i = 0; $i <= $#$fields; ++$i) {
	$pubimg_index = $i and last 
	    if $$fields[$i] eq 'public_images';
    }

    warn("xmdmanager: xproject: catalog $file has no id_text or id_composite field\n") and return
	unless $item_index >= 0;

    for (my $i = 0; $i <= $#$fields; ++$i) {
	$name_index = $i and last 
	    if $$fields[$i] eq 'designation';
    }
    $name_index = -1 if $name_index > $#$fields;
    warn("xmdmanager: catalog $file lacks required designation field\n") and return
	unless $name_index >= 0;
    for (my $i = 0; $i <= $#$fields; ++$i) {
	if ($$fields[$i] eq 'primary_publication') {
	    $pripub_index = $i;
	} elsif (exists $musno_fields{$$fields[$i]}) {
	    push @musno_indices, $i;
	}
    }

#    my $xprojects_index = $#$fields+1;
#    push @$fields, 'xproject';

    foreach my $r (@$rows) {
	my $pq = $$r[$item_index];
	if ($$r[$period_index]) {
	    print PERTAB "$pq\t$$r[$period_index]\n";
	} else {
	    print PERTAB "$pq\tunknown\n";
	}
	my $pl = $$r[$place_index] || 'unknown';
	print LOCTAB "$pq\t$pl\n";
	if ($pq =~ /(?:^|:)P/) {
	    my $pname = $$r[$name_index];
	    $pname =~ s/^\s*(.*?)\s*$/$1/;
	    $pname =~ s/&apos;/'/g;
	    $pname =~ s/&amp;/&/g;
#	    $$r[$xprojects_index] = $xproject{$pq} || 'CDLI';
	    print PNMTAB "$pq\t$pname\n";
	    print PRITAB "$pq\t", strip0($$r[$pripub_index]),"\n"
		if $$r[$pripub_index];
	    foreach my $m (@musno_indices) {
		print MUSTAB "$pq\t",strip0($$r[$m]),"\n"
		    if $$r[$m];
	    }
	    if ($pubimg_index >= 0 && $$r[$pubimg_index] && $$r[$pubimg_index] eq 'yes') {
		print PUBIMG "$pq\n";
		++$pubimg{$pq};
	    } else {
		print PRVIMG "$pq\n";
	    }
	} else {
	    my $qname = $$r[$name_index];
#	    warn "printing $pq\t$qname to QNMTAB\n";
	    print QNMTAB "$pq\t$qname\n" if $pq =~ /(?:^|:)Q/;
#	    $$r[$xprojects_index] = $xproject{$pq} || '';
	}
    }
}

sub
sortkeys {
    if (0 && $project_mode) {
	#FIXME: write an xmlwf() func for ORACC::XML and test keys.xml
	my $xk = load_xml("$results/keys.xml");
	my %s = ();
	foreach my $k ($xk->getDocumentElement()->childNodes()) {
	    $s{$k->getAttribute('ref')} = $k;
	}
	$xk = load_xml("$results/qkeys.xml");
	if ($xk && $xk->getDocumentElement()->hasChildNodes()) {
	    foreach my $k ($xk->getDocumentElement()->childNodes()) {
		$s{$k->getAttribute('ref')} = $k;
	    }
	}
    }
}

sub
strip0 {
    my $tmp = shift;
    $tmp =~ s/([,: \t])0+/$1/;
    $tmp;
}

sub
load_designation_sort_codes {
    open(IN,'00lib/designation-sort-codes.lst');
    while (<IN>) {
	chomp;
	my($q,$c) = split(/\t/,$_);
	$proj_des_sort{$q} = $c;
	$q =~ /^([A-Z])/;
	# track which ID types have project designation codes so we can warn only if an ID of the same type is lacking a code.
	# this allows projects to provide sort codes for Qs but not have to for Ps.
	++$proj_des_sort{$1};
    }
    close(IN);
    $project_designation_codes = 1;
}

sub
load_designation_sort_order {
    my $code = 0;
    open(IN,'00lib/designation-sort-order.lst');
    while (<IN>) {
	chomp;
	my($q,$c) = split(/\t/,$_);
	$proj_des_sort{$q} = ++$code;
	$q =~ /^([A-Z])/;
	# track which ID types have project designation codes so we can warn only if an ID of the same type is lacking a code.
	# this allows projects to provide sort codes for Qs but not have to for Ps.
	++$proj_des_sort{$1};
    }
    close(IN);
    $project_designation_codes = 1;
}

#sub
#extra_init {
#    my @cat = (<00lib/cat.d/*.xml>);
#    foreach my $cat (@cat) {
#	my $xcat = load_xml($cat) || warn "xmdmanager.plx: failure loading $cat: $!\n";
#	if ($xcat) {
#	    foreach my $r ($xcat->getDocumentElement()->childNodes()) {
#		next unless $r->isa('XML::LibXML::Element');
#		my $xid = xid($r);
#		my @tmp = ();
#		foreach my $c ($r->childNodes()) {
#		    next unless $c->isa('XML::LibXML::Element');
#		    my $t = $c->toString(0);
#		    $t =~ s/\sxmlns:xmd=\".*?\"//;
#		    push @tmp, $t;
#		}
#		push @{$extra_catd{$xid}}, @tmp;
#	    }
#	}
#   }
#}

sub
extra_init_hash {
    my @cat = (<00lib/cat.d/*.xml>);
    foreach my $cat (@cat) {
	my $xcat = load_xml($cat) || warn "xmdmanager.plx: failure loading $cat: $!\n";
	if ($xcat) {
	    warn "xmdmanager.plx: loading additional catalogue data from $cat\n";
	    foreach my $r ($xcat->getDocumentElement()->childNodes()) {
		next unless $r->isa('XML::LibXML::Element');
		my $xid = xid($r);
		my %tmp = ();
		foreach my $c ($r->childNodes()) {
		    next unless $c->isa('XML::LibXML::Element');
		    my $t = $c->firstChild();
		    next unless $t;
		    if ($t->isa('XML::LibXML::Text')) {
			my($k,$v) = ($c->localName(),$t->data);
			$tmp{$k} = $v;
			++$catd_fields{$k};
		    } else {
			warn "$cat: $xid: bad data format--must be text only\n";
		    }
		}
		if ($catd{$xid}) {
		    my %c = %${$catd{$xid}};
		    foreach my $k (keys %c) {
			$tmp{$k} = $c{$k} unless $tmp{$k};
		    }
		}
		${$catd{$xid}} = { %tmp };
	    }
	}
    }
    my @tsv = (<00lib/cat.d/*.tsv>);
    foreach my $tsv (@tsv) {
	my @rows = `cat $tsv`; chomp @rows;

	my $r1 = shift @rows;
	if ($r1 !~ /^id_composite|id_text\t/) {
	    warn "$tsv: first row must be field names and first field name must be id_composite or id_text\n";
	    next;
	}

	my @fldnames = split(/\t/, $r1);
	my $fid = shift @fldnames;
	foreach my $f (@fldnames) {
	    ++$catd_fields{$f};
	}
	foreach my $r (@rows) {
	    my @flds = split(/\t/, $r);
	    my $xid = shift @flds;
	    my %tmp = ();
	    @tmp{@fldnames} = @flds;
	    if ($catd{$xid}) {
		my %c = %${$catd{$xid}};
		foreach my $k (keys %c) {
		    $tmp{$k} = $c{$k} unless $tmp{$k};
		}	    
	    }
	    ${$catd{$xid}} = { %tmp };
	}
    }
    
    if ($catd_debug) {
	print CATDUMP "++++++catd_fields\n";
	print CATDUMP Dumper \%catd_fields;
	print CATDUMP "++++++catd\n";
	print CATDUMP Dumper \%catd;
	print CATDUMP "+++++++++\n";
    }
}

#sub
#extra_meta {
#    if (defined $catd{$_[0]}) {
#	my %rec = %{$catd{$_[0]};
#	foreach my $f (keys %rec) {
#	    push @{$xmd_outputs{$curr_xmd}}, "<$f>$rec{$f}</$f>"; #  @{$catd{$_[0]}};
#	}
#    }
#}

sub
import_catd {
    my $cat = shift;
    my $fields = $$cat[0];
    my $id_index = -1;
    my %field_indexes = ();
    my $first_record = 1;

    if ($catd_debug) {
	print CATDUMP Dumper \$cat;
	print CATDUMP "++++++++\n";
    }

    for (my $i = 0; $i <= $#$fields; ++$i) {
	$id_index = $i and last 
	    if $$fields[$i] =~ /^id_(?:text|composite)$/;
    }

    if ($first_record) {
	foreach my $f (keys %catd_fields) {
	    # register the key indexes, creating new ones at the end of the row if necessary as in import routine
	    my $fn_index = -1;
	    for (my $i = 0; $i <= $#$fields; ++$i) {
		$fn_index = $i and last 
		    if $$fields[$i] eq $f;
	    }
	    if (-1 == $fn_index) {
		push @$fields, $f;
		$fn_index = $#$fields;
	    }
	    $field_indexes{$f} = $fn_index;
	}
	$first_record = 0;
    }

    # traverse the data rows looking for records which are mentioned in catd
    my $rows = $$cat[2];
    foreach my $r (@$rows) {
	my $r_id = $$r[$id_index];
	if ($r_id && $catd{$r_id}) {
	    my %c = %${$catd{$r_id}};
	    foreach my $f (keys %c) {
		my $ix = $field_indexes{$f};
		if ($ix) {
		    $$r[$ix] = $c{$f};
		}
	    }
	}
    }

    if ($catd_debug) {
	print CATDUMP Dumper \$cat;
	print CATDUMP "++++++++\n";
    }
}

sub
pleiades_init {
    my $proj = shift;
    my $p = ORACC::XMD::Pleiades::load('00lib/pleiades.tab');
    push(@pleiades_data, $p) if $p;
    unless ($proj eq 'geonames') {
        my $p = ORACC::XMD::Pleiades::load("$ENV{'ORACC'}/pub/geonames/pleiades.tab");
	if ($p) {
	    push(@pleiades_data, $p);
	    warn "geonames/pleiades loaded as $p\n";
	    use Data::Dumper; 
	    if (open(P,'>/tmp/pleiades.dump')) {
		print P Dumper($p); 
		close(P);
	    }
	}
    }
}

sub
xmd_geojson {
    my($f, $r, $p_id,$p_co) = @_;
    my $last = $#$f;
    if ($geojson_first > 0) {
	$geojson_first = -1;
	open(GJ, '>01bld/cat.geojson') || die;
	print GJ "{\n\t\"type\": \"FeatureCollection\",\n\t\"features\": [";
    } else {
	print GJ ", ";
    }
    print GJ "{\n\t\t\"type\": \"Feature\",\n\t\t\"properties\": {\n";
    my $field_first = 1;
    for (my $i = 0; $i <= $last; ++$i) {
	my $val = $$r[$i];
	if ($val) {
	    my $key = $$f[$i];
	    if ($field_first) {
		$field_first = 0;
	    } else {
		print GJ ",\n";
	    }
	    $val = jsonify($val) if $val =~ /["\\\x00-\x1f\x80-\xa0]/;
	    print GJ "\t\t\t\"$key\": \"$val\"";
	}
    }
    print GJ "\n\t\t}";
    if ($p_id && $p_co) {
	print GJ ",\n\t\t\"geometry\": {\n\t\t\t\"type\": \"Point\",\n\t\t\t\"coordinates\": $p_co\n\t\t}\n\t}";
    } else {
	print GJ "\n\t}";
    }
}

sub
xmd_json_begin {
#    warn "xmd_json_begin\n" if $project eq 'rinap/rinap3';
    open(J, '>01bld/catalogue.json') || die;
    print J "{\n\t\"type\": \"catalogue\",\n\t\"project\": \"$project\",\n\t\"members\": {\n";
}

sub
xmd_json_end {
#    warn "xmd_json_end: entry\n" if $project eq 'rinap/rinap3';
    print J "\n\t}\n}\n";
    close J;
}

sub
xmd_json_item {
    my($f, $r, $p_id, $prov_index, $pl_id, $pl_co) = @_;
#    warn "xmd_json_item: @_\n" if $project eq 'rinap/rinap3';
    my $last = $#$f;
    my $field_first = 1;
    if ($json_first == 1) {
	$json_first = 0;
    } else {
	print J ",\n";
    }
    print J "\t\t\"$$r[$p_id]\": {\n";
    my %seen = ();
    for (my $i = 0; $i <= $last; ++$i) {
	next if $i == $p_id;
	my $key = $$f[$i];
	next if $seen{$key}++;
	next if exists $json_ignore{$key};
	my $val = $$r[$i];
	if ($val) {
	    if ($field_first) {
		$field_first = 0;
	    } else {
		print J ",\n";
	    }
	    $val = jsonify($val) if $val =~ /["\\\x00-\x1f\x80-\xa0]/;
	    print J "\t\t\t\"$key\": \"$val\"";
	    if ($i == $prov_index) {
		if ($pl_id) {
		    print J ",\n";
		    print J "\t\t\t\"pleiades\": \"$pl_id\"";
		}
		if ($pl_co) {
		    print J ",\n";
		    print J "\t\t\t\"coords\": $pl_co";
		}
	    }
	}
    }
    print J "\n\t\t}";
}

sub
jsonify {
    my $tmp = shift;
    $tmp =~ s/"/\000"/g;
    $tmp =~ s/\\/\000\\/g;
    $tmp =~ tr/\000/\\/;
    $tmp =~ tr/\x00-\x1f\x80-\x9f//d;
    $tmp =~ tr/\t\xa0/  /;
    $tmp;
}

sub
load_translist {
    if (open(T,'01bld/translist.txt')) {
	while (<T>) {
	    chomp;
	    my @p = split(/\s+/,$_);
	    my $pqx = shift @p;
	    foreach my $p (@p) {
		++${$translist{$pqx}}{$p};
	    }
	}
	close(T);
    }
    if (open(T,'01bld/proxtrans.txt')) {
	while (<T>) {
	    chomp;
	    my @p = split(/\s+/,$_);
	    my $pqx = shift @p;
	    foreach my $p (@p) {	
		unless ($translist{$pqx}) {
		    ++${$translist{$pqx}}{$p};
		}
	    }
	}
	close(T);
    }
}

sub
dump_translist {
    my $id = shift;
    my $tl = ($translist{$id} ? $translist{$id} : undef);
    if ($tl) {
	push @{$xmd_outputs{$curr_xmd}},
		"<trans>", map({ "<tr>$_</tr>" } keys %$tl), '</trans>';
    }
}

sub
xsystem {
    warn "system @_\n" if $verbose;
    system @_;
}

1;

__END__

=head1 NAME

xmdmanager.plx -- manage XML MetaData import, collation and indexing

=head1 SYNOPSIS

xmdmanager.plx [options]

=head1 OPTIONS

=over

=item B<-config>

Give the name of the configuration file; see 
http://oracc.museum.upenn.edu/oracc/doc/XMD/#config
for configuration info.

=item B<-validate>

Perform validation phases and exit.

=item B<-verbose>

Make noise about what is happening.

=back

=head1 DESCRIPTION

Program to manage conversion of metadata managed in FileMaker to XMD
(XML MetaData format).  Configuration is done by an XML data file
giving details on which fields are sortable, collate sequences for
values or collate methods for fields, and how to generate computed
fields from key values.

=head1 AUTHOR

Steve Tinney (stinney@sas.upenn.edu)

=head1 COPYRIGHT

Copyright(c) Steve Tinney 2006.

Released under the Gnu General Public License
(http://www.gnu.org/copyleft/gpl.html).

# 2020020000100 Sargon
# 2040020000100 Erridupizir
#    2147483647
