%define api.prefix {asl}
%file-prefix"asl"
%locations
%define parse.error verbose

%{
#include <stdio.h>
#include <string.h>
#include <mesg.h>
#include "asl.h"
extern int yylex(void);
extern void yyerror(const char *);
extern const char *asltext, *curraslfile;
extern int asllineno, asltrace;
extern int gdl_unicode;

#define ASLLTYPE_IS_DECLARED 1
#define ASLLTYPE Mloc
#define yylineno asllineno
ASLLTYPE asllloc;

int asl_raw_tokens = 0;
int asl_literal_flag = 0;
int minus_flag = 0;
 
%}

%union { char *text; int i; }

%token	<text>  TOK TRANS TAB EOL PAR BAD LINE SIGLUM
		SIGN FAKE AKA COMP PNAME FORM NOFORM
		GNAME GVALUE GVALUEX GOESTO
		GBAD ATF LANG V LIST LISTNUM
		INOTE LIT NOTE REF TEXT END EBAD EFORM ESIGN
		UAGE USEQ UTF8 UMAP UNAME UNOTE UPUA
		SIGNLIST LISTDEF LISTNAME LREF SREF
		SYSDEF SYSNAME SYS SMAP LITERAL

%nterm  <text>  anynote atftoken atftokens lang longtext token

%start fields

%%

fields: blank
	| field
	| fields blank
	| fields field
	;

blank:  EOL
       	| PAR
	;

field: 	  line EOL
	| line PAR	{ if (asltrace) fprintf(stderr, "PAR\n"); }
	| error EOL	{ yyerrok; }
	;

line:	  atcmd		{ if (asltrace) fprintf(stderr, "atcmd/EOL: %s\n", asllval.text); }
	;

longtext:
	  TEXT		{ $$ = longtext(curr_asl, $1, NULL); /* fprintf(stderr,"longtext TEXT %s\n",$1); */ }
        | longtext TAB	{ $$ = longtext(curr_asl, $1, $2);   /* fprintf(stderr,"longtext %s\n\t+ TAB %s\n",$1,$2);*/ }
	;

atcmd:
	  atsignlist
	| atlistdef
	| atsysdef
	| atsign
        | atlref
        | atsref
        | ataka
        | atsmap
        | atcomp
        | atpname
	| atfake
	| atlist
	| atv
	| atsys
	| atform
	| atmeta
	| atunicode
	| atend
        ;

atsignlist:
	  SIGNLIST TEXT { asl_bld_signlist(&@1, (uccp)$2, 0); }
	;

atlistdef:
	  LISTDEF LISTNAME longtext { asl_bld_listdef(&@1, curr_asl, (ccp)$2, (ccp)longtext(NULL,NULL,NULL)); }
	;

atsysdef:
	  SYSDEF SYSNAME	    { asl_bld_sysdef(&@1, curr_asl, (ccp)$2, NULL); }
	| SYSDEF SYSNAME TEXT	    { asl_bld_sysdef(&@1, curr_asl, (ccp)$2, (ccp)$3); }
	;

atsign:
	  SIGN token	 { asl_bld_sign(&@1, curr_asl, (uccp)$2, minus_flag); }
	| SIGN GBAD 	 /* not generated by asl.l yet */
	;

atfake:   FAKE 		{ if (curr_asl->curr_sign && !curr_asl->curr_form) { curr_asl->curr_sign->fake = 1; }
	    		  else { mesg_vwarning(curraslfile, asllineno, "asl: misplaced @fake line\n");  } }
	;

ataka:
	  AKA token 	 { asl_bld_aka(&@1, curr_asl, (uccp)$2); }
	;

atsmap:
	  SMAP token 	 { asl_bld_smap(&@1, curr_asl, (uccp)$2); }
	;

atcomp:
	  COMP token	 { asl_bld_tle(&@1, curr_asl, (uccp)$2, NULL, sx_tle_componly); }
	;

atpname:
	  PNAME token 	 { asl_bld_pname(&@1, curr_asl, (uccp)$2); }
	;

atlist:
          LIST LISTNUM	 { asl_bld_list(&@1, curr_asl, (uccp)$2, minus_flag); }
	;

atlref:
	  LREF LISTNUM 	 { asl_bld_tle(&@1, curr_asl, (uccp)$2, NULL, sx_tle_lref); }
	| LREF LISTNUM GOESTO atftoken
			 { asl_bld_tle(&@1, curr_asl, (uccp)$2, (uccp)$3, sx_tle_lref); }
	;

atsref:
	SREF atftoken GOESTO atftokens { asl_bld_tle(&@1, curr_asl, (uccp)$2, (uccp)$3, sx_tle_sref); }
	;

atform:
	  FORM token 		{ asl_bld_form(&@1, curr_asl, (uccp)$2, minus_flag); }
	| FORM GBAD
	;

atv:
	  V lang ATF     	{ asl_bld_value(&@1, curr_asl, (uccp)$3, (ccp)$2, 1, minus_flag); }
	| V lang GVALUE  	{ asl_bld_value(&@1, curr_asl, (uccp)$3, (ccp)$2, 0, minus_flag); }
	| V lang GBAD 
	;

atsys:
	  SYS SYSNAME atftoken	{ asl_bld_sys(&@1, curr_asl, (ccp)$2, (uccp)$3, NULL); }
	| SYS SYSNAME atftoken GOESTO atftokens {
	  			  asl_bld_sys(&@1, curr_asl, (ccp)$2, (uccp)$3, (uccp)longtext(NULL,NULL,NULL)); }
        ;

atftokens:
	  atftoken		{ $$ = longtext(curr_asl, $1, NULL); }
	| atftokens atftoken	{ $$ = longtext(curr_asl, $1, $2); }
	;

atftoken:
	  ATF
	| token
	;

/*
tokens:
	  token		{ $$ = longtext(curr_asl, $1, NULL); }
	| tokens token  { $$ = longtext(curr_asl, $1, $2); }
	;
 */

token:
	  GNAME
	| GVALUE
	| LISTNUM
	| LITERAL		{ asl_literal_flag = 1; }
	;

/* Possibly add EGROUP ELETTER ESECTION here; note: EFORM no longer used; on ESIGN we should NULL out sl->curr_sign/form/inst */
atend:
	  END ESIGN	    	{ asl_bld_end_sign(&@1, curr_asl); }
	| END EBAD
	;

/* There is no atuhex because we use @list U+ */
atunicode:
	  atuage
	| atuseq
	| atutf8
	| atumap
	| atupua
	| atuname
	| atunote
	;

atuage:
	  UAGE TEXT		{ asl_bld_urev(&@1, curr_asl, (uccp)$2); }
	;

atuseq:
	  USEQ TEXT		{ asl_bld_useq(&@1, curr_asl, (uccp)$2); }
	;

atutf8:
	  UTF8 TEXT		{ asl_bld_utf8(&@1, curr_asl, (uccp)$2); }
	;

atumap:
	  UMAP TEXT		{ asl_bld_umap(&@1, curr_asl, (uccp)$2); }
	;

atupua:
	  UPUA TEXT		{ asl_bld_upua(&@1, curr_asl, (uccp)$2); }
	;

atuname:
	  UNAME	TEXT		{ asl_bld_uname(&@1, curr_asl, (uccp)$2); }
        ;

atunote:
	  UNOTE longtext		{ asl_bld_unote(&@1, curr_asl, (uccp)longtext(NULL,NULL,NULL)); }
	;

atmeta:
	  anynote longtext	{ asl_bld_note(&@1, curr_asl, (ccp)$1, (ccp)$2); }
        ;

anynote:
	  INOTE			{ $$ = "inote"; }
	| LIT			{ $$ = "lit"; }
	| NOTE			{ $$ = "note"; }
	| REF			{ $$ = "ref"; }
	| SYS			{ $$ = "sys"; }
        ;

lang:
	  LANG
	| /* empty */ { $$ = NULL; }
	;

%%

void
aslerror(const char *e)
{
  mesg_vwarning(curraslfile, asllineno, "asl: %s\n", e);
}
