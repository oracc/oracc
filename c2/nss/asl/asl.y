%define api.prefix {asl}
%file-prefix"asl"
%locations
%define parse.error verbose

%{
#include <stdio.h>
#include <string.h>
#include <mesg.h>
#include "asl.h"
extern int yylex(void);
extern void yyerror(const char *);
extern const char *asltext, *curraslfile;
extern int asllineno, asltrace;
extern int gdl_unicode;

#define ASLLTYPE_IS_DECLARED 1
#define ASLLTYPE Mloc
#define yylineno asllineno
ASLLTYPE asllloc;

int asl_raw_tokens = 0;
int minus_flag = 0;
 
%}

%union { char *text; int i; }

%token	<text>  TOK TRANS TAB EOL PAR CMT BAD LINE SIGLUM
		SIGN FAKE AKA PNAME FORM NOFORM VAR
		GNAME GVALUE GVALUEX
		GBAD ATF LANG V VCMT VREF LIST LISTNUM
		INOTE LIT NOTE TEXT END EBAD EFORM ESIGN
		UCHAR UCODE UPHASE UNAME UNOTE SIGNLIST

%nterm  <text>  gname lang vref

%start fields

%%

fields: blank
	| field
	| fields blank
	| fields field
	;

blank:  EOL
       	| PAR
	;

field: 	  line EOL
	| cont EOL
	| line PAR	{ if (asltrace) fprintf(stderr, "PAR\n"); }
	| cont PAR	{ if (asltrace) fprintf(stderr, "PAR\n"); }
	| error EOL	{ yyerrok; }
	;

line:	  atcmd		{ if (asltrace) fprintf(stderr, "atcmd/EOL: %s\n", asllval.text); }
	| CMT 		{ if (asltrace) fprintf(stderr, "comment/EOL: %s\n", asllval.text); }
	;

atcmd:
	  atsignlist
	| atsign
        | ataka
        | atpname
	| atfake
	| atlist
	| atv
	| atform
	| atmeta
	| atunicode
	| atend
        ;

atsignlist:
	  SIGNLIST TEXT { asl_bld_signlist(&@1, curr_asl, (uccp)$2, 0); }
	;

atsign:
	  SIGN gname	 { asl_bld_sign(&@1, curr_asl, (uccp)$2, 0, minus_flag); }
	| SIGN LISTNUM 	 { asl_bld_sign(&@1, curr_asl, (uccp)$2, 1, minus_flag); }
	| SIGN GBAD 	 /* not generated by asl.l yet */
	;

atfake:   FAKE 		{ if (curr_asl->curr_sign && !curr_asl->curr_form) { curr_asl->curr_sign->fake = 1; }
	    		  else { mesg_vwarning(curraslfile, asllineno, "asl: misplaced @fake line\n");  } }

ataka:
	  AKA GVALUE 	 { asl_bld_aka(&@1, curr_asl, (uccp)$2); }
	| AKA GNAME 	 { asl_bld_aka(&@1, curr_asl, (uccp)$2); }

atpname:
	  PNAME GVALUE 	 { asl_bld_pname(&@1, curr_asl, (uccp)$2); }
	| PNAME GNAME 	 { asl_bld_pname(&@1, curr_asl, (uccp)$2); }
	;

atlist:
        LIST LISTNUM	 { asl_bld_list(&@1, curr_asl, (uccp)$2, minus_flag); }
	;

atform:
	  FORM VAR gname vref 	{ asl_bld_form(&@1, curr_asl, (uccp)$3, 0, (uccp)$2, (uccp)$4, minus_flag); }
	| FORM VAR LISTNUM vref { asl_bld_form(&@1, curr_asl, (uccp)$3, 1, (uccp)$2, (uccp)$4, minus_flag); }
	| FORM VAR GBAD
	;

atv:
	  V lang ATF vref    { asl_bld_value(&@1, curr_asl, (uccp)$3, (ccp)$2, (uccp)$4, 1, minus_flag); }
	| V lang GVALUE vref { asl_bld_value(&@1, curr_asl, (uccp)$3, (ccp)$2, (uccp)$4, 0, minus_flag); }
	| V lang GBAD vref
	;

gname:
	  GNAME			
	;

vref:
	  VREF
	| /* empty */ { $$ = NULL; }
	;

/* Possibly add EGROUP ELETTER ESECTION here */
atend:
	  END EFORM
	| END ESIGN
	| END EBAD
	;

atunicode:
	  atuchar
	| atucode
	| atuname
	| atunote
	| atuphase
	;

atuchar:
	  UCHAR TEXT	{ asl_bld_uchar(&@1, curr_asl, (uccp)$2); }
	;

atucode:
	  UCODE TEXT	{ asl_bld_ucode(&@1, curr_asl, (uccp)$2); }
	;

atuname:
	  UNAME TEXT	{ asl_bld_uname(&@1, curr_asl, (uccp)$2); }
	;

atunote:
	  UNOTE	TEXT	{ asl_bld_unote(&@1, curr_asl, (uccp)$2); }
        ;

atuphase:
	  UPHASE TEXT	{ asl_bld_uphase(&@1, curr_asl, (uccp)$2); }
	;

atmeta:
	  atinote
	| atlit
	| atnote
	;

atinote:
	  INOTE	TEXT	{ asl_bld_inote(&@1, curr_asl, (uccp)$2); }
        ;

atlit:
	  LIT	TEXT	{ asl_bld_lit(&@1, curr_asl, (uccp)$2); }
        ;

atnote:
	  NOTE	TEXT	{ asl_bld_note(&@1, curr_asl, (uccp)$2); }
        ;

cont: 	TAB		{ if (asltrace) fprintf(stderr, "field/TAB: %s\n", asllval.text); }
	| cont TAB
	;

lang:
	  LANG
	| /* empty */ { $$ = NULL; }
	;

%%

void
aslerror(const char *e)
{
  mesg_vwarning(curraslfile, asllineno, "asl: %s\n", e);
}
