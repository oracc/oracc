%define api.prefix {asl}
%file-prefix"asl"
%locations
%define parse.error verbose

%{
#include <stdio.h>
#include <string.h>
#include <mesg.h>
#include "asl.h"
extern int yylex(void);
extern void yyerror(const char *);
extern const char *asltext, *curraslfile;
extern int asllineno, asltrace;
extern int gdl_unicode;

#define ASLLTYPE_IS_DECLARED 1
#define ASLLTYPE Mloc
#define yylineno asllineno
ASLLTYPE asllloc;

int asl_raw_tokens = 0;
int minus_flag = 0;
 
%}

%union { char *text; int i; }

%token	<text>  TOK TRANS TAB EOL PAR BAD LINE SIGLUM
		SIGN FAKE AKA COMP PNAME FORM NOFORM
		GNAME GVALUE GVALUEX GOESTO
		GBAD ATF LANG V VREF LIST LISTNUM
		INOTE LIT NOTE TEXT END EBAD EFORM ESIGN
		UCHAR UCODE UPHASE UNAME UNOTE SIGNLIST
		LISTDEF LISTNAME LREF SREF

%nterm  <text>  atftoken lang longtext token vref

%start fields

%%

fields: blank
	| field
	| fields blank
	| fields field
	;

blank:  EOL
       	| PAR
	;

field: 	  line EOL
	| line PAR	{ if (asltrace) fprintf(stderr, "PAR\n"); }
	| error EOL	{ yyerrok; }
	;

line:	  atcmd		{ if (asltrace) fprintf(stderr, "atcmd/EOL: %s\n", asllval.text); }
	;

longtext:
	  TEXT		{ longtext(curr_asl, $1, NULL); /*fprintf(stderr,"longtext TEXT %s\n",$1);*/ }
	| longtext TAB	{ longtext(curr_asl, $1, $2);   /*fprintf(stderr,"longtext TAB %s\n",$2); */ }
	;

atcmd:
	  atsignlist
	| atlistdef
	| atsign
        | atlref
        | atsref
        | ataka
        | atcomp
        | atpname
	| atfake
	| atlist
	| atv
	| atform
	| atmeta
	| atunicode
	| atend
        ;

atsignlist:
	  SIGNLIST TEXT { asl_bld_signlist(&@1, curr_asl, (uccp)$2, 0); }
	;

atlistdef:
	  LISTDEF LISTNAME longtext { asl_bld_listdef(&@1, curr_asl, (ccp)$2, (ccp)longtext(NULL,NULL,NULL)); }
	;

atsign:
	  SIGN token	 { asl_bld_sign(&@1, curr_asl, (uccp)$2, 0, minus_flag); }
	| SIGN GBAD 	 /* not generated by asl.l yet */
	;

atfake:   FAKE 		{ if (curr_asl->curr_sign && !curr_asl->curr_form) { curr_asl->curr_sign->fake = 1; }
	    		  else { mesg_vwarning(curraslfile, asllineno, "asl: misplaced @fake line\n");  } }
	;

ataka:
	  AKA token 	 { asl_bld_aka(&@1, curr_asl, (uccp)$2); }
	;

atcomp:
	  COMP token	 { asl_bld_tle(&@1, curr_asl, (uccp)$2, NULL, sx_tle_componly); }
	;

atpname:
	  PNAME token 	 { asl_bld_pname(&@1, curr_asl, (uccp)$2); }
	;

atlist:
        LIST LISTNUM	 { asl_bld_list(&@1, curr_asl, (uccp)$2, minus_flag); }
	;

atlref:
	  LREF LISTNUM 	 { asl_bld_tle(&@1, curr_asl, (uccp)$2, NULL, sx_tle_lref); }
	| LREF LISTNUM GOESTO atftoken
			 { asl_bld_tle(&@1, curr_asl, (uccp)$2, (uccp)$3, sx_tle_lref); }
	;

atsref:
	SREF token GOESTO token { asl_bld_tle(&@1, curr_asl, (uccp)$2, (uccp)$3, sx_tle_sref); }
	;

atform:
	  FORM token vref 	{ asl_bld_form(&@1, curr_asl, (uccp)$2, 0, (uccp)$3, minus_flag); }
	| FORM GBAD
	;

atv:
	  V lang ATF vref    { asl_bld_value(&@1, curr_asl, (uccp)$3, (ccp)$2, (uccp)$4, 1, minus_flag); }
	| V lang GVALUE vref { asl_bld_value(&@1, curr_asl, (uccp)$3, (ccp)$2, (uccp)$4, 0, minus_flag); }
	| V lang GBAD vref
	;

atftoken:
	  ATF
	| GVALUE
	| token
	;

token:
	  GNAME
	| LISTNUM
	;

vref:
	  VREF
	| /* empty */ { $$ = NULL; }
	;

/* Possibly add EGROUP ELETTER ESECTION here; note: EFORM no longer used; on ESIGN we should NULL out sl->curr_sign/form/inst */
atend:
	  END ESIGN	    { asl_bld_end_sign(&@1, curr_asl); }
	| END EBAD
	;

atunicode:
	  atuchar
	| atucode
	| atuname
	| atunote
	| atuphase
	;

atuchar:
	  UCHAR TEXT	{ asl_bld_uchar(&@1, curr_asl, (uccp)$2); }
	;

atucode:
	  UCODE TEXT	{ asl_bld_ucode(&@1, curr_asl, (uccp)$2); }
	;

atuname:
	  UNAME TEXT	{ asl_bld_uname(&@1, curr_asl, (uccp)$2); }
	;

atunote:
	  UNOTE	TEXT	{ asl_bld_unote(&@1, curr_asl, (uccp)$2); }
        ;

atuphase:
	  UPHASE TEXT	{ asl_bld_uphase(&@1, curr_asl, (uccp)$2); }
	;

atmeta:
	  atinote
	| atlit
	| atnote
	;

atinote:
	  INOTE	TEXT	{ asl_bld_inote(&@1, curr_asl, (uccp)$2); }
        ;

atlit:
	  LIT	TEXT	{ asl_bld_lit(&@1, curr_asl, (uccp)$2); }
        ;

atnote:
	  NOTE	TEXT	{ asl_bld_note(&@1, curr_asl, (uccp)$2); }
        ;

lang:
	  LANG
	| /* empty */ { $$ = NULL; }
	;

%%

void
aslerror(const char *e)
{
  mesg_vwarning(curraslfile, asllineno, "asl: %s\n", e);
}
